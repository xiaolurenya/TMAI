<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M-Team 馒头菠菜</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/axios@1.6.2/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.14.0/dist/tf.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#165DFF',
                        secondary: '#36CFC9',
                        success: '#52C41A',
                        warning: '#FAAD14',
                        danger: '#FF4D4F',
                        dark: '#1F2937',
                        light: '#F9FAFB',
                        purple: '#7B61FF'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto { content-visibility: auto; }
            .card-shadow { box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05); }
            .hover-lift { transition: transform 0.2s, box-shadow 0.2s; }
            .hover-lift:hover { transform: translateY(-2px); box-shadow: 0 6px 16px rgba(0, 0, 0, 0.08); }
            .table-hover-row:hover { background-color: rgba(22, 93, 255, 0.03); }
            .odds-highlight { font-weight: bold; }
            .follower-indicator { position: relative; padding-left: 1.5rem; }
            .follower-indicator::before { content: "→"; position: absolute; left: 0; color: #7B61FF; font-weight: bold; }
            .scrollbar-thin { scrollbar-width: thin; }
            .scrollbar-thin::-webkit-scrollbar { width: 4px; height: 4px; }
            .scrollbar-thin::-webkit-scrollbar-thumb { background-color: rgba(156, 163, 175, 0.5); border-radius: 2px; }
            .ai-tag { display: inline-block; background-color: rgba(123, 97, 255, 0.1); color: #7B61FF; font-size: 0.65rem; font-weight: 600; padding: 0 5px; border-radius: 3px; margin-left: 4px; letter-spacing: 0.3px; text-transform: uppercase; box-shadow: 0 1px 2px rgba(123, 97, 255, 0.1); }
            .confidence-A-plus { background-color: rgba(82, 196, 26, 0.2); color: #52C41A; }
            .confidence-A { background-color: rgba(82, 196, 26, 0.15); color: #52C41A; }
            .confidence-B { background-color: rgba(250, 173, 20, 0.15); color: #FAAD14; }
            .confidence-C { background-color: rgba(255, 77, 79, 0.15); color: #FF4D4F; }
            .strategy-badge { display: inline-block; font-size: 0.7rem; padding: 1px 5px; border-radius: 4px; margin-left: 4px; }
        }
    </style>
</head>
<body class="bg-gray-50 font-sans text-gray-800">
    <div class="container mx-auto px-4 py-6 max-w-7xl">
        <header class="mb-6">
            <div class="bg-white rounded-xl card-shadow p-4 mb-6">
                <div class="flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
                    <h1 class="text-2xl font-bold text-dark flex items-center">
                        <i class="fa fa-line-chart text-primary mr-2"></i>
                        M-Team 馒头菠菜
                        <span class="ml-2 text-sm bg-primary/10 text-primary px-2 py-0.5 rounded-full">AI增强版</span>
                    </h1>
                    <div class="flex items-center space-x-4 w-full md:w-auto">
                        <div class="flex items-center bg-gray-100 px-3 py-1.5 rounded-lg">
                            <span id="serviceStatusIndicator" class="inline-block w-3 h-3 rounded-full bg-gray-400 mr-2"></span>
                            <span id="serviceStatusText" class="text-sm font-medium">服务未运行</span>
                        </div>
                        <div class="flex gap-2 flex-1 md:flex-none">
                            <button id="startServiceBtn" onclick="startService()" class="flex-1 bg-success hover:bg-success/90 text-white px-4 py-2 rounded-lg transition hover-lift flex items-center justify-center">
                                <i class="fa fa-play mr-2"></i> 启动服务
                            </button>
                            <button id="stopServiceBtn" onclick="stopService()" class="flex-1 bg-danger hover:bg-danger/90 text-white px-4 py-2 rounded-lg transition hover-lift opacity-50 cursor-not-allowed" disabled>
                                <i class="fa fa-stop mr-2"></i> 停止服务
                            </button>
                        </div>
                    </div>
                </div>
                <div class="flex flex-wrap gap-3 pt-2 text-sm">
                    <div class="flex items-center bg-gray-50 px-3 py-1.5 rounded-lg">
                        <span class="text-gray-600 mr-2">刷新间隔:</span>
                        <span id="refreshIntervalDisplay" class="font-mono text-primary">00:00:30.000</span>
                    </div>
                    <button id="autoRefreshBtn" onclick="toggleAutoRefresh()" class="text-primary hover:text-primary/80 flex items-center px-3 py-1.5 rounded-lg hover:bg-primary/5 transition">
                        <i class="fa fa-refresh mr-1"></i> 关闭自动刷新
                    </button>
                    <button onclick="manualRefresh()" class="text-primary hover:text-primary/80 flex items-center px-3 py-1.5 rounded-lg hover:bg-primary/5 transition">
                        <i class="fa fa-sync mr-1"></i> 手动刷新
                    </button>
                    <button onclick="toggleLogModal()" class="text-primary hover:text-primary/80 flex items-center px-3 py-1.5 rounded-lg hover:bg-primary/5 transition ml-auto">
                        <i class="fa fa-list-alt mr-1"></i> 查看日志
                    </button>
                </div>
            </div>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
            <div class="lg:col-span-2 space-y-6">
                <div class="bg-white rounded-xl card-shadow overflow-hidden transition-all duration-300 hover-lift">
                    <div class="bg-gray-50 px-5 py-4 border-b border-gray-100">
                        <h2 class="text-lg font-semibold flex items-center">
                            <i class="fa fa-list-ol text-primary mr-2"></i> 可投注项目
                            <span id="availableBetsCount" class="ml-2 text-sm font-normal text-gray-500">0 个项目</span>
                        </h2>
                    </div>
                    <div class="p-4">
                        <div class="overflow-x-auto scrollbar-thin">
                            <table id="betItemsTable" class="min-w-full divide-y divide-gray-200">
                                <tr>
                                    <td colspan="8" class="border border-gray-200 p-8 text-center text-gray-500">
                                        <div class="flex flex-col items-center">
                                            <i class="fa fa-inbox text-3xl mb-2 text-gray-300"></i>
                                            <span>请启动服务加载数据</span>
                                        </div>
                                    </td>
                                </tr>
                            </table>
                        </div>
                    </div>
                </div>

                <div class="bg-white rounded-xl card-shadow overflow-hidden transition-all duration-300 hover-lift">
                    <div class="bg-gray-50 px-5 py-4 border-b border-gray-100">
                        <h2 class="text-lg font-semibold flex items-center">
                            <i class="fa fa-clock-o text-primary mr-2"></i> 待投注项目
                            <span id="pendingBetsCount" class="ml-2 text-sm font-normal text-gray-500">0 个项目</span>
                            <span id="currentStrategyBadge" class="ml-3 text-xs bg-gray-100 text-gray-600 px-2 py-0.5 rounded-full">策略: 未启动</span>
                        </h2>
                    </div>
                    <div class="p-4">
                        <div class="overflow-x-auto scrollbar-thin">
                            <table id="pendingBetsTable" class="min-w-full divide-y divide-gray-200">
                                <tr>
                                    <td colspan="8" class="border border-gray-200 p-8 text-center text-gray-500">
                                        <div class="flex flex-col items-center">
                                            <i class="fa fa-hourglass-o text-3xl mb-2 text-gray-300"></i>
                                            <span>暂无待投注项目</span>
                                        </div>
                                    </td>
                                </tr>
                            </table>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <div class="md:col-span-2 bg-white rounded-xl card-shadow overflow-hidden transition-all duration-300 hover-lift">
                        <div class="bg-gray-50 px-5 py-4 border-b border-gray-100">
                            <h2 class="text-lg font-semibold flex items-center">
                                <i class="fa fa-history text-primary mr-2"></i> 操作日志
                            </h2>
                        </div>
                        <div id="logPanel" class="h-48 overflow-y-auto p-4 border-t border-gray-100 text-sm scrollbar-thin"></div>
                    </div>
                    <div class="bg-white rounded-xl card-shadow overflow-hidden transition-all duration-300 hover-lift">
                        <div class="bg-gray-50 px-5 py-4 border-b border-gray-100">
                            <h2 class="text-lg font-semibold flex items-center">
                                <i class="fa fa-trophy text-primary mr-2"></i> 策略表现
                            </h2>
                        </div>
                        <div id="strategyPerformancePanel" class="p-4 border-t border-gray-100 text-sm">
                            <div class="space-y-3">
                                <div>
                                    <div class="flex justify-between mb-1">
                                        <span class="text-gray-600">高赔率策略</span>
                                        <span class="font-medium">--</span>
                                    </div>
                                    <div class="w-full bg-gray-200 rounded-full h-1.5">
                                        <div class="bg-primary h-1.5 rounded-full" style="width: 0%"></div>
                                    </div>
                                </div>
                                <div>
                                    <div class="flex justify-between mb-1">
                                        <span class="text-gray-600">AI预测策略</span>
                                        <span class="font-medium">--</span>
                                    </div>
                                    <div class="w-full bg-gray-200 rounded-full h-1.5">
                                        <div class="bg-purple h-1.5 rounded-full" style="width: 0%"></div>
                                    </div>
                                </div>
                                <div>
                                    <div class="flex justify-between mb-1">
                                        <span class="text-gray-600">跟随策略</span>
                                        <span class="font-medium">--</span>
                                    </div>
                                    <div class="w-full bg-gray-200 rounded-full h-1.5">
                                        <div class="bg-secondary h-1.5 rounded-full" style="width: 0%"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="lg:col-span-1 space-y-6">
                <div class="bg-white rounded-xl card-shadow overflow-hidden transition-all duration-300 hover-lift">
                    <div class="bg-gray-50 px-5 py-4 border-b border-gray-100">
                        <h2 class="text-lg font-semibold flex items-center">
                            <i class="fa fa-cog text-primary mr-2"></i> 基本配置
                        </h2>
                    </div>
                    <div class="p-5 space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">API Key</label>
                            <input type="text" id="apiKeyInput" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition" placeholder="输入API Key">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">目标用户ID (跟随模式)</label>
                            <input type="text" id="targetUserIdInput" value="205809" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">投注策略</label>
                            <select id="betStrategySelect" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                                <option value="auto">智能自动切换 <span class="ai-tag">AI</span></option>
                                <option value="higher_odds">最高赔率优先 <span class="ai-tag">AI</span></option>
                                <option value="follow">跟随目标用户</option>
                                <option value="larger">押大</option>
                                <option value="smaller">押小</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">提前下注时间 (秒)</label>
                            <input type="number" id="advanceSecondsInput" value="3" min="0" max="60" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">容忍时间 (秒)</label>
                            <input type="number" id="toleranceSecondsInput" value="1" min="0" max="300" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                        </div>
                    </div>
                </div>

                <div class="bg-white rounded-xl card-shadow overflow-hidden transition-all duration-300 hover-lift">
                    <div class="bg-gray-50 px-5 py-4 border-b border-gray-100">
                        <h2 class="text-lg font-semibold flex items-center">
                            <i class="fa fa-money text-primary mr-2"></i> 金额设置
                        </h2>
                    </div>
                    <div class="p-5 space-y-4">
                        <div>
                            <label class="flex items-center">
                                <input type="checkbox" id="kellyCriterionEnabledCheckbox" checked class="form-checkbox h-5 w-5 text-primary rounded focus:ring-primary/50">
                                <span class="ml-2 text-sm text-gray-700">启用凯利公式计算投注金额</span>
                            </label>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">总资金量</label>
                            <input type="number" id="totalFundInput" value="50000" min="1000" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">基础投注金额 (凯利公式禁用时使用)</label>
                            <input type="number" id="baseAmountInput" value="1000" min="100" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">最大投注比例 (%)</label>
                            <input type="number" id="maxBetRatioInput" value="10" min="1" max="50" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                        </div>
                    </div>
                </div>

                <div class="bg-white rounded-xl card-shadow overflow-hidden transition-all duration-300 hover-lift">
                    <div class="bg-gray-50 px-5 py-4 border-b border-gray-100">
                        <h2 class="text-lg font-semibold flex items-center">
                            <i class="fa fa-brain text-purple mr-2"></i> AI预测配置
                        </h2>
                    </div>
                    <div class="p-5 space-y-4">
                        <div>
                            <label class="flex items-center">
                                <input type="checkbox" id="aiPredictionEnabledCheckbox" checked class="form-checkbox h-5 w-5 text-primary rounded focus:ring-primary/50">
                                <span class="ml-2 text-sm text-gray-700">启用AI预测</span>
                            </label>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">最低置信度阈值 (%)</label>
                            <input type="number" id="minConfidenceThresholdInput" value="60" min="50" max="90" step="5" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">赔率波动敏感度</label>
                            <select id="oddsVolatilitySensitivityInput" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                                <option value="low">低 (稳定优先)</option>
                                <option value="medium" selected>中 (平衡)</option>
                                <option value="high">高 (捕捉机会)</option>
                            </select>
                        </div>
                        <div>
                            <label class="flex items-center">
                                <input type="checkbox" id="dynamicPredictionEnabledCheckbox" checked class="form-checkbox h-5 w-5 text-primary rounded focus:ring-primary/50">
                                <span class="ml-2 text-sm text-gray-700">启用实时动态预测修正</span>
                            </label>
                        </div>
                    </div>
                </div>

                <div class="bg-white rounded-xl card-shadow overflow-hidden transition-all duration-300 hover-lift">
                    <div class="bg-gray-50 px-5 py-4 border-b border-gray-100">
                        <h2 class="text-lg font-semibold flex items-center">
                            <i class="fa fa-refresh text-primary mr-2"></i> 刷新设置
                        </h2>
                    </div>
                    <div class="p-5 space-y-4">
                        <div class="grid grid-cols-3 gap-2">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">时</label>
                                <input type="number" id="refreshHoursInput" value="1" min="0" max="23" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">分</label>
                                <input type="number" id="refreshMinutesInput" value="0" min="0" max="59" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">秒</label>
                                <input type="number" id="refreshSecondsInput" value="30" min="5" max="60" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                            </div>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">检查间隔 (秒)</label>
                            <input type="number" id="checkIntervalInput" value="2" min="0.1" step="0.1" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">跟随检查间隔 (毫秒)</label>
                            <input type="number" id="followCheckIntervalInput" value="500" min="100" max="3000" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                        </div>
                    </div>
                </div>

                <div class="bg-white rounded-xl card-shadow overflow-hidden transition-all duration-300 hover-lift">
                    <div class="bg-gray-50 px-5 py-4 border-b border-gray-100">
                        <h2 class="text-lg font-semibold flex items-center">
                            <i class="fa fa-calendar-check-o text-primary mr-2"></i> 定时任务
                        </h2>
                    </div>
                    <div class="p-5 space-y-4">
                        <div>
                            <label class="flex items-center">
                                <input type="checkbox" id="schedule1EnabledCheckbox" class="form-checkbox h-5 w-5 text-primary rounded focus:ring-primary/50">
                                <span class="ml-2 text-sm text-gray-700">启用第一组定时任务</span>
                            </label>
                            <div class="mt-2 grid grid-cols-2 gap-2 pl-7">
                                <div>
                                    <label class="block text-xs text-gray-500 mb-1">开始时间</label>
                                    <input type="time" id="schedule1StartTimeInput" value="09:00" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition text-sm">
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-500 mb-1">结束时间</label>
                                    <input type="time" id="schedule1StopTimeInput" value="23:00" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition text-sm">
                                </div>
                            </div>
                        </div>
                        <div>
                            <label class="flex items-center">
                                <input type="checkbox" id="schedule2EnabledCheckbox" class="form-checkbox h-5 w-5 text-primary rounded focus:ring-primary/50">
                                <span class="ml-2 text-sm text-gray-700">启用第二组定时任务</span>
                            </label>
                            <div class="mt-2 grid grid-cols-2 gap-2 pl-7">
                                <div>
                                    <label class="block text-xs text-gray-500 mb-1">开始时间</label>
                                    <input type="time" id="schedule2StartTimeInput" value="00:00" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition text-sm">
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-500 mb-1">结束时间</label>
                                    <input type="time" id="schedule2StopTimeInput" value="06:00" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition text-sm">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="bg-white rounded-xl card-shadow overflow-hidden transition-all duration-300 hover-lift">
                    <div class="bg-gray-50 px-5 py-4 border-b border-gray-100">
                        <h2 class="text-lg font-semibold flex items-center">
                            <i class="fa fa-filter text-primary mr-2"></i> 其他设置
                        </h2>
                    </div>
                    <div class="p-5 space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">待投注筛选</label>
                            <select id="pendingFilterSelect" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                                <option value="all">全部</option>
                                <option value="highest_odds">最高赔率</option>
                                <option value="highest_amount">最高金额</option>
                                <option value="ratio_based">最佳比例</option>
                                <option value="high_confidence">高置信度AI预测</option>
                            </select>
                        </div>
                        <div>
                            <label class="flex items-center">
                                <input type="checkbox" id="detailedLogModeCheckbox" class="form-checkbox h-5 w-5 text-primary rounded focus:ring-primary/50">
                                <span class="ml-2 text-sm text-gray-700">详细日志模式</span>
                            </label>
                        </div>
                        <button onclick="saveParameters()" class="w-full bg-primary hover:bg-primary/90 text-white py-2.5 rounded-lg transition hover-lift">
                            保存配置
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="logModal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-xl w-full max-w-4xl max-h-[90vh] flex flex-col shadow-xl">
            <div class="p-4 border-b flex justify-between items-center">
                <h3 class="font-semibold text-lg">详细日志</h3>
                <div class="flex space-x-2">
                    <button onclick="Logger.clear()" class="text-sm text-gray-600 hover:text-gray-900 px-3 py-1 rounded hover:bg-gray-100 transition">
                        <i class="fa fa-trash mr-1"></i> 清空
                    </button>
                    <button onclick="toggleLogModal()" class="text-gray-600 hover:text-gray-900 p-1 rounded-full hover:bg-gray-100 transition">
                        <i class="fa fa-times"></i>
                    </button>
                </div>
            </div>
            <div id="logModalPanel" class="flex-1 overflow-y-auto p-4 text-sm scrollbar-thin"></div>
        </div>
    </div>

    <script>
        // 安全机制
        (function() {
            const antiDebug = () => {
                if (window.outerHeight - window.innerHeight > 200 || window.outerWidth - window.innerWidth > 200) {
                    document.body.innerHTML = '<div class="flex items-center justify-center h-screen bg-danger text-white text-xl">检测到非法调试行为，系统已保护</div>';
                    return;
                }
                requestAnimationFrame(antiDebug);
            };
            antiDebug();

            document.addEventListener('contextmenu', e => e.preventDefault());
            document.addEventListener('selectstart', e => e.preventDefault());
            document.addEventListener('keydown', e => {
                if (e.key === 'F12' || (e.ctrlKey && e.shiftKey && e.key === 'I')) {
                    e.preventDefault();
                    alert('禁止调试');
                }
            });
        })();

        if (typeof axios === 'undefined') {
            document.write('<script src="https://unpkg.com/axios@1.6.2/dist/axios.min.js"><\/script>');
        }

        // 字符串哈希函数
        String.prototype.hashCode = function() {
            let hash = 0;
            for (let i = 0; i < this.length; i++) {
                const char = this.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash);
        };

        // 全局变量
        let autoRefreshTimer = null;
        let betCheckTimer = null;
        let followCheckTimers = {};
        let pendingBets = [];
        let isServiceRunning = false;
        let logModalVisible = false;
        let lastActivityTime = 0;
        let isPageVisible = true;
        let countdownTimer = null;
        let refreshCycleStartTime = 0;
        let scheduleTimers = { check1: null, check2: null };
        
        const AIAnalytics = {
            historicalData: {},
            predictionCache: {},
            oddsHistory: {},
            model: null,
            modelReady: false,
            strategyPerformance: {
                higher_odds: { wins: 0, losses: 0, total: 0, profit: 0 },
                ai_prediction: { wins: 0, losses: 0, total: 0, profit: 0 },
                follow: { wins: 0, losses: 0, total: 0, profit: 0 },
                larger: { wins: 0, losses: 0, total: 0, profit: 0 },
                smaller: { wins: 0, losses: 0, total: 0, profit: 0 }
            },
            currentStrategy: null,
            strategyFailureCount: {}
        };
        
        const GlobalInfo = {
            bet_mask: {},
            available_bets: [],
            my_bet_log: [],
            configs: {},
            followedBets: {},
            matchDetails: {}
        };

        // 日志系统
        const Logger = {
            logs: [],
            detailedMode: false,
            log(content, level = "INFO", detailed = false) {
                if (detailed && !this.detailedMode) return;
                
                const now = new Date().toLocaleString("zh-CN", {
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    fractionalSecondDigits: 3
                });
                const logItem = `[${now}] [${level}] ${content}`;
                this.logs.unshift(logItem);
                if (this.logs.length > 500) this.logs.pop();
                this.render();
            },
            info(content, detailed = false) { this.log(content, "INFO", detailed); },
            error(content, detailed = false) { this.log(content, "ERROR", detailed); },
            warning(content, detailed = false) { this.log(content, "WARN", detailed); },
            clear() {
                this.logs = [];
                this.render();
                this.info("日志已清空");
            },
            render() {
                const mainPanel = document.getElementById('logPanel');
                if (mainPanel) {
                    mainPanel.innerHTML = this.logs.map(log => 
                        `<div class="py-1 ${log.includes('ERROR') ? 'text-danger' : log.includes('WARN') ? 'text-warning' : ''}">${log}</div>`
                    ).join("");
                    mainPanel.scrollTop = mainPanel.scrollHeight;
                }
                
                const modalPanel = document.getElementById('logModalPanel');
                if (modalPanel) {
                    modalPanel.innerHTML = this.logs.map(log => 
                        `<div class="py-1 ${log.includes('ERROR') ? 'text-danger' : log.includes('WARN') ? 'text-warning' : ''}">${log}</div>`
                    ).join("");
                    modalPanel.scrollTop = modalPanel.scrollHeight;
                }
            },
            toggleDetailedMode(enabled) {
                this.detailedMode = enabled;
                this.info(`详细日志模式已${enabled ? '开启' : '关闭'}`, true);
            }
        };

        // 配置（API逻辑未修改）
        const CONFIG = {
            mainHost: "https://api.m-team.io/api",
            testHost: "https://test2.m-team.cc/api",
            sportsDataHost: "https://api.sportsdata.io/v3",
            sportsApiKey: "your_sports_api_key",
            apis: {
                "get_current_bet": "bet/findBetgameList?active=LIVE&fix=0",
                "betgameOdds": "bet/betgameOdds?optId={optId}&bonus={bonus}",
                "get_details": "bet/getDetail?gameId={gameId}",
                "get_gamblers": "bet/getDetailBetList?gameId={gameId}",
                "get_my_bet_log": "bet/myCouponLog",
                "get_team_history": "team/getHistory?teamId={teamId}",
                "team_stats": "/basketball/stats/json/TeamGameStatsBySeason/{teamId}/{season}",
                "head_to_head": "/basketball/stats/json/HeadToHead/{teamId1}/{teamId2}",
                "injuries": "/basketball/stats/json/Injuries/{league}"
            },
            state: {
                availableBets: [],
                autoRefresh: true,
                refreshInterval: 30,
                targetUserId: "205809",
                advanceSeconds: 3,
                toleranceSeconds: 1,
                amountRange: 200,
                baseAmount: 1000,
                totalFund: 50000,
                maxBetRatio: 10,
                kellyCriterionEnabled: true,
                betStrategy: "auto",
                checkInterval: 2,
                detailedLogMode: false,
                pendingFilter: "all",
                aiPredictionEnabled: true,
                minConfidenceThreshold: 60,
                oddsVolatilitySensitivity: "medium",
                dynamicPredictionEnabled: true,
                followCheckInterval: 500,
                schedule1Enabled: false,
                schedule1StartTime: "09:00",
                schedule1StopTime: "23:00",
                schedule2Enabled: false,
                schedule2StartTime: "00:00",
                schedule2StopTime: "06:00"
            }
        };

        // 核心请求函数（未修改）
        async function request(url, method = 'post', data = {}, retry = 1) {
            try {
                const response = await axios({
                    method,
                    url,
                    data,
                    headers: {
                        "x-api-key": document.getElementById("apiKeyInput").value || "",
                        "Content-Type": "application/json"
                    },
                    timeout: 15000
                });
                Logger.info(`请求成功: ${url}`, true);
                return response.data;
            } catch (e) {
                Logger.error(`请求失败: ${e.message} (${url})`, true);
                if (retry > 0) {
                    Logger.warning(`尝试重试请求: ${url}`, true);
                    return request(url, method, data, retry - 1);
                }
                throw new Error(`请求失败: ${e.message}`);
            }
        }

        // 体育数据请求函数（未修改）
        async function requestSportsData(endpoint, params = {}) {
            try {
                const url = `${CONFIG.sportsDataHost}${endpoint}`;
                const response = await axios({
                    method: 'get',
                    url,
                    params: {
                        key: CONFIG.sportsApiKey,
                        ...params
                    },
                    timeout: 10000
                });
                Logger.info(`体育数据请求成功: ${url}`, true);
                return response.data;
            } catch (e) {
                Logger.warning(`体育数据请求失败: ${e.message}，使用备用数据源`, true);
                try {
                    return generateMockSportsData(endpoint);
                } catch (e2) {
                    Logger.error(`体育数据获取失败: ${e2.message}`, true);
                    return null;
                }
            }
        }

        // 生成模拟体育数据
        function generateMockSportsData(endpoint) {
            if (endpoint.includes("TeamGameStatsBySeason")) {
                return {
                    Wins: Math.floor(Math.random() * 10) + 20,
                    Losses: Math.floor(Math.random() * 10) + 10,
                    HomeWins: Math.floor(Math.random() * 5) + 10,
                    HomeLosses: Math.floor(Math.random() * 5) + 5,
                    AwayWins: Math.floor(Math.random() * 5) + 10,
                    AwayLosses: Math.floor(Math.random() * 5) + 5,
                    LastFiveGames: Array.from({length: 5}, () => ({
                        Score: Math.floor(Math.random() * 20) + 80,
                        OpponentScore: Math.floor(Math.random() * 20) + 80,
                        Win: Math.random() > 0.5
                    }))
                };
            } else if (endpoint.includes("HeadToHead")) {
                return {
                    Games: Math.floor(Math.random() * 5) + 5,
                    Team1Wins: Math.floor(Math.random() * 5) + 1,
                    Team2Wins: Math.floor(Math.random() * 5) + 1,
                    AveragePointDifference: (Math.random() * 10) - 5
                };
            } else if (endpoint.includes("Injuries")) {
                return Array.from({length: Math.floor(Math.random() * 3) + 1}, () => ({
                    Player: `Player ${Math.floor(Math.random() * 100)}`,
                    Position: ['PG', 'SG', 'SF', 'PF', 'C'][Math.floor(Math.random() * 5)],
                    Injury: ['膝盖受伤', '脚踝扭伤', '背部紧张', '流感'][Math.floor(Math.random() * 4)],
                    Status: ['出战成疑', '大概率缺阵', '确定缺阵'][Math.floor(Math.random() * 3)]
                }));
            }
            return null;
        }

        // API验证逻辑（未修改）
        async function verifyApiKey() {
            const apiKey = document.getElementById("apiKeyInput").value;
            if (!apiKey) {
                Logger.warning("请输入API Key");
                return false;
            }

            try {
                Logger.info("正在验证API Key（通过获取投注列表）...");
                const result = await request(`${CONFIG.mainHost}/${CONFIG.apis.get_current_bet}`);
                if (result && (result.data || result.code === 0)) {
                    Logger.info("API Key验证成功");
                    return true;
                } else {
                    Logger.error(`API Key验证失败: 响应格式不正确`);
                    return false;
                }
            } catch (e) {
                Logger.warning("主服务器验证失败，尝试备用服务器...");
                try {
                    const result = await request(`${CONFIG.testHost}/${CONFIG.apis.get_current_bet}`);
                    if (result && (result.data || result.code === 0)) {
                        Logger.info("备用服务器API Key验证成功");
                        return true;
                    } else {
                        Logger.error(`备用服务器API Key验证失败: 响应格式不正确`);
                        return false;
                    }
                } catch (e2) {
                    Logger.error(`API Key验证失败: ${e2.message}`);
                    return false;
                }
            }
        }

        // 初始化AI模型
        async function initAIModel() {
            try {
                Logger.info("正在初始化AI预测模型...");
                
                if (AIAnalytics.modelReady && AIAnalytics.model) {
                    Logger.info("AI模型已准备就绪", true);
                    return true;
                }
                
                AIAnalytics.model = tf.sequential();
                AIAnalytics.model.add(tf.layers.dense({
                    units: 1,
                    inputShape: [8],
                    activation: 'sigmoid'
                }));
                
                AIAnalytics.model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'binaryCrossentropy',
                    metrics: ['accuracy']
                });
                
                const trainData = generateMockTrainingData(1000);
                const xs = tf.tensor2d(trainData.features);
                const ys = tf.tensor2d(trainData.labels);
                
                await AIAnalytics.model.fit(xs, ys, {
                    epochs: 10,
                    batchSize: 32,
                    verbose: 0
                });
                
                xs.dispose();
                ys.dispose();
                
                AIAnalytics.modelReady = true;
                Logger.info("AI预测模型初始化完成");
                return true;
            } catch (e) {
                Logger.error(`AI模型初始化失败: ${e.message}`);
                AIAnalytics.modelReady = false;
                return false;
            }
        }

        // 生成模拟训练数据
        function generateMockTrainingData(count) {
            const features = [];
            const labels = [];
            
            for (let i = 0; i < count; i++) {
                const winRate = Math.random();
                const homeWinRate = Math.random();
                const awayWinRate = Math.random();
                const recentWinRate = Math.random();
                const h2hWinRate = Math.random();
                const avgScoreDiff = (Math.random() * 20) - 10;
                const oddsDiff = (Math.random() * 1) - 0.5;
                const injuryImpact = Math.random();
                
                features.push([
                    winRate,
                    homeWinRate,
                    awayWinRate,
                    recentWinRate,
                    h2hWinRate,
                    avgScoreDiff / 10,
                    oddsDiff + 0.5,
                    1 - injuryImpact
                ]);
                
                const label = (
                    0.3 * winRate + 
                    0.1 * homeWinRate + 
                    0.1 * awayWinRate + 
                    0.2 * recentWinRate + 
                    0.2 * h2hWinRate + 
                    0.05 * (avgScoreDiff + 10) / 20 + 
                    0.03 * (oddsDiff + 0.5) + 
                    0.02 * (1 - injuryImpact)
                ) > 0.5 ? 1 : 0;
                
                labels.push([label]);
            }
            
            return { features, labels };
        }

        // 获取可投注项目
        async function loadBetItems() {
            updateLastActivity();
            try {
                Logger.info("正在获取可投注项目...", true);
                const data = await request(`${CONFIG.mainHost}/${CONFIG.apis.get_current_bet}`);
                CONFIG.state.availableBets = Array.isArray(data?.data) ? data.data : [];
                GlobalInfo.available_bets = CONFIG.state.availableBets;
                
                Logger.info(`找到可下注项目（${CONFIG.state.availableBets.length} 个）`);
                document.getElementById("availableBetsCount").textContent = `${CONFIG.state.availableBets.length} 个项目`;
                
                CONFIG.state.availableBets.forEach((betitem, idx) => {
                    Logger.info(`[ ${idx + 1} / ${CONFIG.state.availableBets.length} ] 项目id: ${betitem.id} 结束时间： ${betitem.endtime}`);
                    Logger.info(`${betitem.heading}, ${betitem.undertext || ''}`);
                    
                    if (!AIAnalytics.oddsHistory[betitem.id]) {
                        AIAnalytics.oddsHistory[betitem.id] = {};
                    }
                    
                    if (betitem.optionsList && betitem.optionsList.length > 0) {
                        Logger.info(`可下注选项(共${betitem.optionsList.length}个)：`, true);
                        betitem.optionsList.forEach((opt, optIdx) => {
                            Logger.info(`  [${optIdx + 1}] ${opt.text} (赔率: ${opt.odds})`, true);
                            
                            if (!AIAnalytics.oddsHistory[betitem.id][opt.id]) {
                                AIAnalytics.oddsHistory[betitem.id][opt.id] = [];
                            }
                            AIAnalytics.oddsHistory[betitem.id][opt.id].push({
                                odds: parseFloat(opt.odds),
                                timestamp: new Date().getTime()
                            });
                            
                            if (AIAnalytics.oddsHistory[betitem.id][opt.id].length > 10) {
                                AIAnalytics.oddsHistory[betitem.id][opt.id].shift();
                            }
                        });
                    }
                    
                    detectOddsAnomalies(betitem.id);
                    
                    if (CONFIG.state.betStrategy !== "follow" && CONFIG.state.aiPredictionEnabled) {
                        analyzeWithAI(betitem);
                    }
                    
                    if (CONFIG.state.betStrategy === "follow" && isServiceRunning) {
                        startFollowingCheck(betitem.id);
                    }
                });
                
                if (CONFIG.state.betStrategy === "auto" && isServiceRunning) {
                    selectOptimalStrategy();
                }
                
                await flushConfig();
                processPendingBets(true);
                renderBetTable();
                updateStrategyPerformancePanel();
                resetRefreshCycle();
                return true;
            } catch (e) {
                Logger.warning("主服务器获取失败，尝试备用服务器...");
                try {
                    const data = await request(`${CONFIG.testHost}/${CONFIG.apis.get_current_bet}`);
                    CONFIG.state.availableBets = Array.isArray(data?.data) ? data.data : [];
                    GlobalInfo.available_bets = CONFIG.state.availableBets;
                    
                    Logger.info(`从备用服务器找到可下注项目（${CONFIG.state.availableBets.length} 个）`);
                    document.getElementById("availableBetsCount").textContent = `${CONFIG.state.availableBets.length} 个项目`;
                    
                    await flushConfig();
                    processPendingBets(true);
                    renderBetTable();
                    updateStrategyPerformancePanel();
                    resetRefreshCycle();
                    return true;
                } catch (e2) {
                    Logger.error(`获取投注项目失败: ${e2.message}`);
                    resetRefreshCycle();
                    return false;
                }
            }
        }

        // 检测赔率异常波动
        function detectOddsAnomalies(gameId) {
            const oddsHistory = AIAnalytics.oddsHistory[gameId];
            if (!oddsHistory) return;
            
            const now = new Date().getTime();
            
            Object.entries(oddsHistory).forEach(([optionId, history]) => {
                if (history.length < 3) return;
                
                const recentHistory = history.filter(entry => now - entry.timestamp < 5 * 60 * 1000);
                if (recentHistory.length < 3) return;
                
                const firstOdds = recentHistory[0].odds;
                const lastOdds = recentHistory[recentHistory.length - 1].odds;
                const changePercent = ((lastOdds - firstOdds) / firstOdds) * 100;
                
                let threshold = 5;
                if (CONFIG.state.oddsVolatilitySensitivity === "low") {
                    threshold = 3;
                } else if (CONFIG.state.oddsVolatilitySensitivity === "high") {
                    threshold = 8;
                }
                
                if (Math.abs(changePercent) >= threshold) {
                    const betItem = CONFIG.state.availableBets.find(item => item.id === gameId);
                    const option = betItem?.optionsList.find(opt => opt.id === optionId);
                    
                    if (option) {
                        Logger.warning(`赔率异常波动: 项目 #${gameId} ${option.text} 变化 ${changePercent.toFixed(2)}% (${firstOdds} → ${lastOdds})`);
                        
                        if (CONFIG.state.dynamicPredictionEnabled) {
                            const item = CONFIG.state.availableBets.find(item => item.id === gameId);
                            if (item) {
                                analyzeWithAI(item);
                            }
                        }
                    }
                }
            });
        }

        // 刷新配置
        async function flushConfig() {
            const availableBets = GlobalInfo.available_bets;
            const newConfigs = {};
            
            GlobalInfo.bet_mask = {};
            
            availableBets.forEach(bet => {
                const id = bet.id;
                GlobalInfo.bet_mask[id] = [];
                
                const endTime = new Date(bet.endtime);
                const scheduledTime = new Date(endTime.getTime() - CONFIG.state.advanceSeconds * 1000);
                const scheduledTimeMulti = new Date(endTime.getTime() - CONFIG.state.advanceSeconds * 1000);
                
                newConfigs[id] = {
                    bet_id: id,
                    desc: `${bet.heading}, ${bet.undertext || ''}`,
                    scheduled_time: scheduledTime,
                    scheduled_time_multi: scheduledTimeMulti,
                    endtime: bet.endtime,
                    bias: CONFIG.state.advanceSeconds,
                    bonus: CONFIG.state.baseAmount,
                    option_type: CONFIG.state.betStrategy
                };
            });
            
            GlobalInfo.configs = newConfigs;
            Logger.info(`配置已刷新，应用统一提前下注(${CONFIG.state.advanceSeconds}s)和容忍时间(${CONFIG.state.toleranceSeconds}s)`, true);
        }

        // 处理待投注项目
        function processPendingBets(refresh = false) {
            const now = new Date();
            const processingItems = refresh ? pendingBets.filter(bet => bet.status === "处理中") : [];
            let newPendingBets = [...processingItems];
            
            const candidateBets = [];
            Object.values(GlobalInfo.configs).forEach(cfg => {
                if (processingItems.some(bet => bet.id === cfg.bet_id)) {
                    return;
                }
                
                try {
                    const betItem = CONFIG.state.availableBets.find(item => item.id === cfg.bet_id);
                    if (!betItem) return;
                    
                    if (CONFIG.state.betStrategy === "follow") {
                        return;
                    }
                    
                    const betTime = cfg.scheduled_time;
                    const toleranceTime = new Date(new Date(cfg.endtime).getTime() + CONFIG.state.toleranceSeconds * 1000);
                    
                    if (betTime > now && betTime < toleranceTime) {
                        if (shouldPlaceBet(betItem)) {
                            const aiPrediction = AIAnalytics.predictionCache[betItem.id];
                            
                            if (CONFIG.state.pendingFilter === "high_confidence" && 
                                (!aiPrediction || aiPrediction.confidence * 100 < CONFIG.state.minConfidenceThreshold)) {
                                Logger.info(`项目 #${betItem.id} AI置信度不足(${aiPrediction ? (aiPrediction.confidence * 100).toFixed(1) : 0}%)，已过滤`, true);
                                return;
                            }
                            
                            const selectedOption = aiPrediction 
                                ? betItem.optionsList.find(opt => opt.text.includes(aiPrediction.prediction))
                                : getHighestOddsOption(betItem);
                            
                            const betAmount = calculateBetAmount(betItem, selectedOption);
                            const odds = selectedOption ? parseFloat(selectedOption.odds) : 0;
                            const ratioValue = odds * betAmount;
                            
                            candidateBets.push({
                                ...betItem,
                                id: cfg.bet_id,
                                betTime,
                                betAmount,
                                strategy: AIAnalytics.currentStrategy || CONFIG.state.betStrategy,
                                status: "等待中",
                                highestOdds: odds,
                                highestOddsTeam: selectedOption ? selectedOption.text : 'N/A',
                                ratioValue: ratioValue,
                                recordedOdds: odds,
                                aiPrediction: aiPrediction ? `${aiPrediction.prediction} (${(aiPrediction.confidence * 100).toFixed(1)}%)` : null,
                                aiPredictionConfidence: aiPrediction ? aiPrediction.confidence : 0,
                                aiPredictionLevel: aiPrediction ? aiPrediction.confidenceLevel : null,
                                aiPredictedTeam: aiPrediction ? aiPrediction.prediction : null
                            });
                        }
                    }
                } catch (e) {
                    Logger.error(`处理项目 #${cfg.bet_id} 失败: ${e.message}`, true);
                }
            });
            
            let selectedBets = [];
            const betsByTimeGroup = {};
            candidateBets.forEach(bet => {
                const timeGroup = new Date(bet.betTime).toLocaleString('zh-CN', { 
                    year: 'numeric', 
                    month: '2-digit', 
                    day: '2-digit', 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                
                if (!betsByTimeGroup[timeGroup]) {
                    betsByTimeGroup[timeGroup] = [];
                }
                betsByTimeGroup[timeGroup].push(bet);
            });
            
            switch (CONFIG.state.pendingFilter) {
                case "all":
                    Object.values(betsByTimeGroup).forEach(group => {
                        selectedBets.push(...group);
                        Logger.info(`时间组 ${new Date(group[0].betTime).toLocaleString()} 选择所有 ${group.length} 个项目`, true);
                    });
                    break;
                case "highest_odds":
                    Object.values(betsByTimeGroup).forEach(group => {
                        if (group.length === 0) return;
                        const selected = group.reduce((max, bet) => bet.highestOdds > max.highestOdds ? bet : max, group[0]);
                        selectedBets.push(selected);
                        Logger.info(`时间组 ${new Date(group[0].betTime).toLocaleString()} 选择最高赔率项目 #${selected.id} (${selected.highestOdds})`, true);
                    });
                    break;
                case "highest_amount":
                    Object.values(betsByTimeGroup).forEach(group => {
                        if (group.length === 0) return;
                        const selected = group.reduce((max, bet) => bet.betAmount > max.betAmount ? bet : max, group[0]);
                        selectedBets.push(selected);
                        Logger.info(`时间组 ${new Date(group[0].betTime).toLocaleString()} 选择最高金额项目 #${selected.id} (${selected.betAmount})`, true);
                    });
                    break;
                case "ratio_based":
                    Object.values(betsByTimeGroup).forEach(group => {
                        if (group.length === 0) return;
                        const selected = group.reduce((max, bet) => bet.ratioValue > max.ratioValue ? bet : max, group[0]);
                        selectedBets.push(selected);
                        Logger.info(`时间组 ${new Date(group[0].betTime).toLocaleString()} 选择最佳比例项目 #${selected.id} (${selected.ratioValue.toFixed(2)})`, true);
                    });
                    break;
                case "high_confidence":
                    Object.values(betsByTimeGroup).forEach(group => {
                        if (group.length === 0) return;
                        const sorted = [...group].sort((a, b) => b.aiPredictionConfidence - a.aiPredictionConfidence);
                        selectedBets.push(sorted[0]);
                        Logger.info(`时间组 ${new Date(group[0].betTime).toLocaleString()} 选择最高置信度项目 #${sorted[0].id} (${(sorted[0].aiPredictionConfidence * 100).toFixed(1)}%)`, true);
                    });
                    break;
            }
            
            newPendingBets = [...newPendingBets, ...selectedBets];
            newPendingBets.sort((a, b) => a.betTime - b.betTime);
            pendingBets = newPendingBets;
            document.getElementById("pendingBetsCount").textContent = `${pendingBets.length} 个项目`;
            renderPendingBetsTable();
        }

        // 获取目标用户的投注记录
        async function getTargetUserBet(gameId) {
            try {
                Logger.info(`尝试获取目标用户 ${CONFIG.state.targetUserId} 的投注记录 (项目 #${gameId})`, true);
               const url = `${CONFIG.mainHost}/${CONFIG.apis.get_gamblers.replace('{gameId}', gameId)}`;
               const data = await request(url);
                
                if (data?.data && Array.isArray(data.data)) {
                    const targetBet = data.data.find(log => log.userid === CONFIG.state.targetUserId);
                    if (targetBet) {
                        Logger.info(`找到目标用户 ${CONFIG.state.targetUserId} 的投注记录: 选项 ${targetBet.optionid}, 金额 ${targetBet.bonus}`, true);
                    } else {
                        Logger.info(`未找到目标用户 ${CONFIG.state.targetUserId} 的投注记录`, true);
                    }
                    return targetBet;
                }
                return null;
            } catch (e) {
                Logger.warning(`获取用户投注记录失败: ${e.message}，尝试备用服务器`, true);
                try {
                const url = `${CONFIG.testHost}/${CONFIG.apis.get_gamblers.replace('{gameId}', gameId)}`;
                const data = await request(url);
                    
                    if (data?.data && Array.isArray(data.data)) {
                        const targetBet = data.data.find(log => log.userid === CONFIG.state.targetUserId);
                        return targetBet;
                    }
                    return null;
                } catch (e2) {
                    Logger.error(`获取用户投注记录失败: ${e2.message}`, true);
                    return null;
                }
            }
        }

        // 启动跟随检查
        function startFollowingCheck(gameId) {
            if (followCheckTimers[gameId]) {
                clearInterval(followCheckTimers[gameId]);
            }
            
            if (GlobalInfo.followedBets[gameId]) {
                return;
            }
            
            const checkInterval = CONFIG.state.followCheckInterval;
            Logger.info(`开始实时监控项目 #${gameId} 的目标用户投注 (检查间隔: ${checkInterval}ms)`, true);
            
            followCheckTimers[gameId] = setInterval(async () => {
                if (!isServiceRunning) {
                    clearInterval(followCheckTimers[gameId]);
                    delete followCheckTimers[gameId];
                    return;
                }
                
                const betItem = CONFIG.state.availableBets.find(item => item.id === gameId);
                if (!betItem) {
                    clearInterval(followCheckTimers[gameId]);
                    delete followCheckTimers[gameId];
                    Logger.info(`项目 #${gameId} 已失效，停止监控`, true);
                    return;
                }
                
                const endTime = new Date(betItem.endtime);
                const now = new Date();
                if (now > new Date(endTime.getTime() + CONFIG.state.toleranceSeconds * 1000)) {
                    clearInterval(followCheckTimers[gameId]);
                    delete followCheckTimers[gameId];
                    Logger.info(`项目 #${gameId} 已超过容忍时间，停止监控`, true);
                    return;
                }
                
                const targetBet = await getTargetUserBet(gameId);
                if (targetBet) {
                    const option = betItem.optionsList.find(opt => opt.id === targetBet.optionid);
                    if (!option) {
                        Logger.error(`跟随投注失败: 选项 ${targetBet.optionid} 不存在`);
                        clearInterval(followCheckTimers[gameId]);
                        delete followCheckTimers[gameId];
                        return;
                    }
                    
                    Logger.info(`检测到目标用户 ${CONFIG.state.targetUserId} 已投注项目 #${gameId} - ${option.text}，准备立即跟随`, true);
                    
                    const followBet = {
                        ...betItem,
                        id: gameId,
                        betTime: now,
                        betAmount: calculateFollowAmount(targetBet.bonus),
                        strategy: "follow",
                        status: "处理中",
                        highestOddsTeam: option.text,
                        highestOdds: parseFloat(option.odds || 0),
                        ratioValue: 0,
                        recordedOdds: 0,
                        aiPredictedTeam: null
                    };
                    
                    pendingBets.unshift(followBet);
                    renderPendingBetsTable();
                    
                    const success = await placeFollowBet(followBet, targetBet.optionid);
                    
                    const index = pendingBets.findIndex(b => b.id === gameId && b.status === "处理中");
                    if (index !== -1) {
                        pendingBets[index].status = success ? "已完成" : "失败";
                        renderPendingBetsTable();
                    }
                    
                    if (success) {
                        GlobalInfo.followedBets[gameId] = {
                            optionId: targetBet.optionid,
                            amount: followBet.betAmount
                        };
                        
                        updateStrategyPerformance("follow", success);
                        
                        Logger.info(`跟随投注成功，3秒后自动刷新可投注项目...`);
                        setTimeout(() => loadBetItems(), 3000);
                    } else {
                        updateStrategyPerformance("follow", success);
                    }
                    
                    clearInterval(followCheckTimers[gameId]);
                    delete followCheckTimers[gameId];
                }
            }, checkInterval);
        }

        // 计算跟随金额
        function calculateFollowAmount(baseAmount) {
            const base = parseInt(baseAmount) || 0;
            const bias = Math.floor(Math.random() * (CONFIG.state.amountRange * 2 + 1)) - CONFIG.state.amountRange;
            return Math.max(base + bias, 100);
        }

        // 执行跟随投注
        async function placeFollowBet(followBet, optionId) {
            updateLastActivity();
            try {
                Logger.info(`开始跟随投注项目 #${followBet.id}，选项: ${followBet.highestOddsTeam}, 金额: ${followBet.betAmount}`);
                
                const option = followBet.optionsList.find(opt => opt.id === optionId);
                if (!option) {
                    Logger.error(`跟随投注失败: 选项 ${optionId} 不存在`);
                    return false;
                }
                
                const url = `${CONFIG.mainHost}/${CONFIG.apis.betgameOdds
                    .replace('{optId}', optionId)
                    .replace('{bonus}', followBet.betAmount)}`;
                
                const result = await request(url);
                
                const isSuccess = result.code === 0 || 
                                  result.code === 1 ||
                                  (result.msg && (result.msg.includes("成功") || result.msg.includes("已下注") || result.msg.includes("投注成功")));
                
                if (!isSuccess) {
                    Logger.error(`跟随投注失败: ${result.msg || '未知错误'}`);
                    return false;
                }
                
                Logger.info(`跟随投注成功: 项目 #${followBet.id}，选项 ${followBet.highestOddsTeam}，金额 ${followBet.betAmount}`);
                
                if (!GlobalInfo.bet_mask[followBet.id]) {
                    GlobalInfo.bet_mask[followBet.id] = [];
                }
                GlobalInfo.bet_mask[followBet.id].push(optionId);
                
                return true;
            } catch (e) {
                Logger.warning("主服务器跟随投注失败，尝试备用服务器...");
                try {
                    const url = `${CONFIG.testHost}/${CONFIG.apis.betgameOdds
                        .replace('{optId}', optionId)
                        .replace('{bonus}', followBet.betAmount)}`;
                    
                    const result = await request(url);
                    
                    const isSuccess = result.code === 0 || 
                                      result.code === 1 ||
                                      (result.msg && (result.msg.includes("成功") || result.msg.includes("已下注") || result.msg.includes("投注成功")));
                    
                    if (!isSuccess) {
                        Logger.error(`备用服务器 - 跟随投注失败: ${result.msg || '未知错误'}`);
                        return false;
                    }
                    
                    Logger.info(`备用服务器 - 跟随投注成功: 项目 #${followBet.id}，选项 ${followBet.highestOddsTeam}，金额 ${followBet.betAmount}`);
                    
                    if (!GlobalInfo.bet_mask[followBet.id]) {
                        GlobalInfo.bet_mask[followBet.id] = [];
                    }
                    GlobalInfo.bet_mask[followBet.id].push(optionId);
                    
                    return true;
                } catch (e2) {
                    Logger.error(`跟随投注请求失败: ${e2.message}`);
                    return false;
                }
            }
        }

        // 获取最高赔率选项
        function getHighestOddsOption(betItem) {
            if (!betItem.optionsList || betItem.optionsList.length === 0) return null;
            
            let highestOdds = -Infinity;
            let highestOption = null;
            
            betItem.optionsList.forEach(option => {
                const odds = parseFloat(option.odds);
                if (odds > highestOdds) {
                    highestOdds = odds;
                    highestOption = option;
                }
            });
            
            return highestOption;
        }

        // 获取押大/小选项
        async function getLargerOptions(gameId) {
            try {
                const url = `${CONFIG.mainHost}/${CONFIG.apis.get_details.replace('{gameId}', gameId)}`;
                const data = await request(url);
                
                if (!data?.data || !data.data.optionsList) return [];
                
                const options = data.data.optionsList;
                if (options.length > 3) return [];
                
                let minOddsIndex = 0;
                options.forEach((opt, idx) => {
                    if (parseFloat(opt.odds) <= parseFloat(options[minOddsIndex].odds)) {
                        minOddsIndex = idx;
                    }
                });
                
                return options.filter((_, idx) => idx !== minOddsIndex).map(opt => opt.id);
            } catch (e) {
                Logger.error(`获取押大选项失败: ${e.message}`, true);
                return [];
            }
        }

        async function getSmallerOptions(gameId) {
            try {
                const url = `${CONFIG.mainHost}/${CONFIG.apis.get_details.replace('{gameId}', gameId)}`;
				                const data = await request(url);
                
                if (!data?.data || !data.data.optionsList) return [];
                
                const options = data.data.optionsList;
                if (options.length > 3) return [];
                
                let maxOddsIndex = 0;
                options.forEach((opt, idx) => {
                    if (parseFloat(opt.odds) >= parseFloat(options[maxOddsIndex].odds)) {
                        maxOddsIndex = idx;
                    }
                });
                
                return options.filter((_, idx) => idx !== maxOddsIndex).map(opt => opt.id);
            } catch (e) {
                Logger.error(`获取押小选项失败: ${e.message}`, true);
                return [];
            }
        }

        // AI分析模块
        async function analyzeWithAI(betItem) {
            try {
                Logger.info(`开始AI分析项目 #${betItem.id}...`, true);
                
                if (!AIAnalytics.modelReady) {
                    await initAIModel();
                    if (!AIAnalytics.modelReady) {
                        Logger.warning(`AI模型未准备就绪，使用基础算法进行预测`, true);
                        return basicPrediction(betItem);
                    }
                }
                
                const teams = betItem.optionsList.map(opt => opt.text.trim());
                if (teams.length < 2) {
                    Logger.warning(`项目 #${betItem.id} 队伍信息不足，无法进行AI分析`, true);
                    return null;
                }
                
                const currentSeason = new Date().getFullYear().toString();
                const teamDataPromises = teams.map(team => 
                    fetchTeamDetailedData(team, currentSeason)
                );
                const teamDataArray = await Promise.all(teamDataPromises);
                
                const teamIds = teams.map(team => team.hashCode());
                const headToHeadData = teamIds.length >= 2 
                    ? await fetchHeadToHeadData(teamIds[0], teamIds[1])
                    : null;
                
                const injuriesData = await fetchInjuryData('NBA');
                const prediction = predictWinnerWithML(teamDataArray, teams, betItem, headToHeadData, injuriesData);
                
                AIAnalytics.predictionCache[betItem.id] = prediction;
                Logger.info(`AI分析完成项目 #${betItem.id}: 预测 ${prediction.prediction} (可信度: ${(prediction.confidence * 100).toFixed(1)}%，等级: ${prediction.confidenceLevel})`);
                
                renderBetTable();
                return prediction;
            } catch (e) {
                Logger.warning(`项目 #${betItem.id} 的AI分析失败: ${e.message}，使用备用预测方法`, true);
                return basicPrediction(betItem);
            }
        }

        // 基础预测算法
        function basicPrediction(betItem) {
            try {
                const highestOption = getHighestOddsOption(betItem);
                if (!highestOption) return null;
                
                let confidence = 0.5 + (parseFloat(highestOption.odds) - 1) * 0.2;
                confidence = Math.min(1, Math.max(0.5, confidence));
                
                let confidenceLevel = 'C';
                if (confidence >= 0.9) confidenceLevel = 'A+';
                else if (confidence >= 0.8) confidenceLevel = 'A';
                else if (confidence >= 0.7) confidenceLevel = 'B';
                
                return {
                    prediction: highestOption.text,
                    confidence,
                    confidenceLevel,
                    factors: {
                        reason: "使用高赔率基础预测"
                    }
                };
            } catch (e) {
                Logger.error(`基础预测算法失败: ${e.message}`, true);
                return null;
            }
        }

        // 获取队伍详细数据
        async function fetchTeamDetailedData(teamName, season) {
            const teamId = teamName.hashCode();
            
            if (AIAnalytics.historicalData[teamId] && 
                new Date().getTime() - AIAnalytics.historicalData[teamId].timestamp < 3600000) {
                return AIAnalytics.historicalData[teamId];
            }
            
            try {
                Logger.info(`获取队伍 "${teamName}" 的详细数据...`, true);
                
                const teamStats = await requestSportsData(
                    CONFIG.apis.team_stats.replace('{teamId}', teamId).replace('{season}', season)
                );
                
                if (!teamStats) {
                    Logger.warning(`无法获取队伍 "${teamName}" 的数据，使用缓存或默认值`, true);
                    return AIAnalytics.historicalData[teamId] || generateDefaultTeamData(teamName);
                }
                
                const totalGames = teamStats.Wins + teamStats.Losses;
                const winRate = totalGames > 0 ? teamStats.Wins / totalGames : 0.5;
                const homeWinRate = (teamStats.HomeWins + teamStats.HomeLosses) > 0 
                    ? teamStats.HomeWins / (teamStats.HomeWins + teamStats.HomeLosses) 
                    : 0.5;
                const awayWinRate = (teamStats.AwayWins + teamStats.AwayLosses) > 0 
                    ? teamStats.AwayWins / (teamStats.AwayWins + teamStats.AwayLosses) 
                    : 0.5;
                
                let recentWins = 0;
                if (teamStats.LastFiveGames && teamStats.LastFiveGames.length > 0) {
                    recentWins = teamStats.LastFiveGames.filter(game => game.Win).length;
                }
                const recentWinRate = recentWins / 5;
                
                let avgScoreDiff = 0;
                if (teamStats.LastFiveGames && teamStats.LastFiveGames.length > 0) {
                    avgScoreDiff = teamStats.LastFiveGames.reduce((sum, game) => 
                        sum + (game.Score - game.OpponentScore), 0) / teamStats.LastFiveGames.length;
                }
                
                const teamData = {
                    teamName,
                    teamId,
                    wins: teamStats.Wins,
                    losses: teamStats.Losses,
                    winRate,
                    homeWinRate,
                    awayWinRate,
                    recentWinRate,
                    avgScoreDiff,
                    recentScores: teamStats.LastFiveGames || [],
                    timestamp: new Date().getTime()
                };
                
                AIAnalytics.historicalData[teamId] = teamData;
                return teamData;
            } catch (e) {
                Logger.warning(`获取队伍 "${teamName}" 数据失败: ${e.message}，使用默认数据`, true);
                return generateDefaultTeamData(teamName);
            }
        }

        // 生成默认队伍数据
        function generateDefaultTeamData(teamName) {
            const teamId = teamName.hashCode();
            const wins = Math.floor(Math.random() * 30) + 10;
            const losses = Math.floor(Math.random() * 20) + 5;
            const totalGames = wins + losses;
            
            return {
                teamName,
                teamId,
                wins,
                losses,
                winRate: wins / totalGames,
                homeWinRate: Math.random(),
                awayWinRate: Math.random(),
                recentWinRate: Math.random(),
                avgScoreDiff: (Math.random() * 20) - 10,
                recentScores: Array.from({length: 5}, () => ({
                    Score: Math.floor(Math.random() * 20) + 80,
                    OpponentScore: Math.floor(Math.random() * 20) + 80,
                    Win: Math.random() > 0.5
                })),
                timestamp: new Date().getTime()
            };
        }

        // 获取对战记录
        async function fetchHeadToHeadData(teamId1, teamId2) {
            try {
                Logger.info(`获取队伍 #${teamId1} 和 #${teamId2} 的对战记录...`, true);
                
                const h2hData = await requestSportsData(
                    CONFIG.apis.head_to_head.replace('{teamId1}', teamId1).replace('{teamId2}', teamId2)
                );
                
                if (!h2hData) {
                    Logger.warning(`无法获取对战记录，使用默认值`, true);
                    return {
                        games: 5,
                        team1Wins: Math.floor(Math.random() * 5) + 1,
                        team2Wins: 5 - (Math.floor(Math.random() * 5) + 1),
                        averagePointDifference: (Math.random() * 10) - 5
                    };
                }
                
                return {
                    games: h2hData.Games,
                    team1Wins: h2hData.Team1Wins,
                    team2Wins: h2hData.Team2Wins,
                    averagePointDifference: h2hData.AveragePointDifference
                };
            } catch (e) {
                Logger.warning(`获取对战记录失败: ${e.message}，使用默认值`, true);
                return {
                    games: 5,
                    team1Wins: Math.floor(Math.random() * 5) + 1,
                    team2Wins: 5 - (Math.floor(Math.random() * 5) + 1),
                    averagePointDifference: (Math.random() * 10) - 5
                };
            }
        }

        // 获取伤病数据
        async function fetchInjuryData(league) {
            try {
                Logger.info(`获取 ${league} 联赛的伤病数据...`, true);
                
                const injuries = await requestSportsData(
                    CONFIG.apis.injuries.replace('{league}', league)
                );
                
                if (!injuries) {
                    Logger.warning(`无法获取伤病数据，使用默认值`, true);
                    return [];
                }
                
                return injuries;
            } catch (e) {
                Logger.warning(`获取伤病数据失败: ${e.message}，使用默认值`, true);
                return [];
            }
        }

        // 使用机器学习模型预测获胜者
        function predictWinnerWithML(teamDataArray, teamNames, betItem, headToHeadData, injuriesData) {
            const validData = teamDataArray.filter(data => data !== null);
            if (validData.length < 2) {
                return basicPrediction(betItem);
            }
            
            const features = extractFeatures(validData[0], validData[1], headToHeadData, injuriesData, betItem);
            const input = tf.tensor2d([features]);
            
            const predictionTensor = AIAnalytics.model.predict(input);
            const predictionValue = predictionTensor.dataSync()[0];
            
            // 释放张量内存
            input.dispose();
            predictionTensor.dispose();
            
            const predictedTeamIndex = predictionValue >= 0.5 ? 0 : 1;
            const predictedTeam = validData[predictedTeamIndex].teamName;
            const confidence = Math.max(predictionValue, 1 - predictionValue);
            
            let confidenceLevel = 'C';
            if (confidence >= 0.9) confidenceLevel = 'A+';
            else if (confidence >= 0.8) confidenceLevel = 'A';
            else if (confidence >= 0.7) confidenceLevel = 'B';
            
            const factors = analyzeKeyFactors(features, validData, headToHeadData);
            
            return {
                prediction: predictedTeam,
                confidence,
                confidenceLevel,
                factors
            };
        }

        // 提取特征用于机器学习
        function extractFeatures(team1, team2, headToHeadData, injuriesData, betItem) {
            const team1WinRate = team1.winRate;
            const team2WinRate = team2.winRate;
            const team1HomeWinRate = team1.homeWinRate;
            const team2AwayWinRate = team2.awayWinRate;
            const team1RecentWinRate = team1.recentWinRate;
            const team2RecentWinRate = team2.recentWinRate;
            
            const team1H2HWinRate = headToHeadData ? 
                headToHeadData.team1Wins / (headToHeadData.team1Wins + headToHeadData.team2Wins) : 0.5;
            
            const team1AvgScoreDiff = team1.avgScoreDiff;
            
            const team1Option = betItem.optionsList.find(opt => opt.text.includes(team1.teamName));
            const team2Option = betItem.optionsList.find(opt => opt.text.includes(team2.teamName));
            const team1Odds = team1Option ? parseFloat(team1Option.odds) : 1;
            const team2Odds = team2Option ? parseFloat(team2Option.odds) : 1;
            const oddsRatio = team1Odds / (team1Odds + team2Odds);
            
            const injuryImpact = injuriesData.length > 0 ? 1 - (1 / (injuriesData.length + 1)) : 0;
            
            return [
                team1WinRate,
                team1HomeWinRate,
                team2AwayWinRate,
                team1RecentWinRate,
                team1H2HWinRate,
                (team1AvgScoreDiff + 10) / 20,
                oddsRatio,
                1 - injuryImpact
            ];
        }

        // 分析关键影响因素
        function analyzeKeyFactors(features, teamData, headToHeadData) {
            const weights = [0.3, 0.1, 0.1, 0.2, 0.2, 0.05, 0.03, 0.02];
            const contributions = features.map((val, idx) => val * weights[idx]);
            const maxContributionIdx = contributions.indexOf(Math.max(...contributions));
            
            const featureNames = [
                "整体胜率",
                "主场胜率",
                "对手客场胜率",
                "近期胜率",
                "对战胜率",
                "平均得分差",
                "赔率因素",
                "伤病影响"
            ];
            
            return {
                keyFactor: featureNames[maxContributionIdx],
                contribution: (contributions[maxContributionIdx] * 100).toFixed(1) + '%',
                team1Stats: {
                    winRate: (teamData[0].winRate * 100).toFixed(1) + '%',
                    recentWinRate: (teamData[0].recentWinRate * 100).toFixed(1) + '%'
                },
                team2Stats: {
                    winRate: (teamData[1].winRate * 100).toFixed(1) + '%',
                    recentWinRate: (teamData[1].recentWinRate * 100).toFixed(1) + '%'
                },
                h2hStats: headToHeadData ? {
                    games: headToHeadData.games,
                    team1Wins: headToHeadData.team1Wins
                } : null
            };
        }

        // 智能选择最优策略
        function selectOptimalStrategy() {
            const strategyScores = {};
            const prevStrategy = AIAnalytics.currentStrategy;
            
            Object.entries(AIAnalytics.strategyPerformance).forEach(([strategy, stats]) => {
                if (stats.total < 5) {
                    strategyScores[strategy] = 0.5;
                } else {
                    const winRate = stats.wins / stats.total;
                    const profitRatio = stats.total > 0 ? stats.profit / (stats.total * CONFIG.state.baseAmount) : 0;
                    strategyScores[strategy] = winRate * 0.6 + Math.max(0, profitRatio) * 0.4;
                }
            });
            
            const maxFailureThreshold = 3;
            Object.entries(AIAnalytics.strategyFailureCount).forEach(([strategy, count]) => {
                if (count >= maxFailureThreshold) {
                    strategyScores[strategy] *= 0.5;
                    Logger.warning(`策略 ${strategy} 已连续失败 ${count} 次，降低优先级`);
                }
            });
            
            const betItems = CONFIG.state.availableBets;
            const hasHighOddsItems = betItems.some(item => {
                const highest = getHighestOddsOption(item);
                return highest && parseFloat(highest.odds) >= 1.8;
            });
            
            const hasClearFavoriteItems = betItems.some(item => {
                if (item.optionsList.length < 2) return false;
                const odds = item.optionsList.map(opt => parseFloat(opt.odds));
                return Math.max(...odds) / Math.min(...odds) >= 1.5;
            });
            
            const hasCompetitiveItems = betItems.some(item => {
                if (item.optionsList.length < 2) return false;
                const odds = item.optionsList.map(opt => parseFloat(opt.odds));
                return Math.max(...odds) / Math.min(...odds) < 1.2;
            });
            
            if (hasHighOddsItems) {
                strategyScores.higher_odds *= 1.2;
            }
            if (hasClearFavoriteItems) {
                strategyScores.larger *= 1.1;
                strategyScores.smaller *= 1.1;
            }
            if (hasCompetitiveItems && CONFIG.state.aiPredictionEnabled) {
                strategyScores.ai_prediction *= 1.3;
            }
            
            let bestStrategy = Object.keys(strategyScores).reduce((a, b) => 
                strategyScores[a] > strategyScores[b] ? a : b
            );
            
            if (bestStrategy === "ai_prediction" && !CONFIG.state.aiPredictionEnabled) {
                bestStrategy = "higher_odds";
            }
            
            if (AIAnalytics.currentStrategy !== bestStrategy) {
                // 从跟随模式切换时清理定时器
                if (prevStrategy === "follow" && bestStrategy !== "follow") {
                    stopAllFollowChecks();
                }
                
                Logger.info(`策略自动切换: ${AIAnalytics.currentStrategy || '无'} → ${bestStrategy} (得分: ${strategyScores[bestStrategy].toFixed(3)})`);
                AIAnalytics.currentStrategy = bestStrategy;
                
                const strategyNames = {
                    higher_odds: "最高赔率优先",
                    ai_prediction: "AI预测",
                    follow: "跟随目标用户",
                    larger: "押大",
                    smaller: "押小"
                };
                document.getElementById("currentStrategyBadge").textContent = 
                    `策略: ${strategyNames[bestStrategy] || bestStrategy}`;
                document.getElementById("currentStrategyBadge").className = 
                    `ml-3 text-xs ${bestStrategy === 'ai_prediction' ? 'bg-purple/10 text-purple' : 'bg-primary/10 text-primary'} px-2 py-0.5 rounded-full`;
            }
            
            return bestStrategy;
        }

        // 更新策略表现统计
        function updateStrategyPerformance(strategy, isWin, profit = 0) {
            const strategyMap = {
                'higher_odds': 'higher_odds',
                'follow': 'follow',
                'larger': 'larger',
                'smaller': 'smaller',
                'auto': AIAnalytics.currentStrategy || 'higher_odds'
            };
            
            const actualStrategy = strategyMap[strategy] || strategy;
            
            if (!AIAnalytics.strategyPerformance[actualStrategy]) {
                AIAnalytics.strategyPerformance[actualStrategy] = {
                    wins: 0,
                    losses: 0,
                    total: 0,
                    profit: 0
                };
            }
            
            const stats = AIAnalytics.strategyPerformance[actualStrategy];
            stats.total++;
            if (isWin) {
                stats.wins++;
                stats.profit += profit;
                AIAnalytics.strategyFailureCount[actualStrategy] = 0;
            } else {
                stats.losses++;
                AIAnalytics.strategyFailureCount[actualStrategy] = 
                    (AIAnalytics.strategyFailureCount[actualStrategy] || 0) + 1;
            }
            
            updateStrategyPerformancePanel();
            
            if (CONFIG.state.betStrategy === "auto") {
                selectOptimalStrategy();
            }
        }

        // 更新策略表现面板
        function updateStrategyPerformancePanel() {
            const panel = document.getElementById("strategyPerformancePanel");
            if (!panel) return;
            
            let html = '<div class="space-y-3">';
            
            const strategies = [
                { id: 'higher_odds', name: '高赔率策略', color: 'bg-primary' },
                { id: 'ai_prediction', name: 'AI预测策略', color: 'bg-purple' },
                { id: 'follow', name: '跟随策略', color: 'bg-secondary' }
            ];
            
            strategies.forEach(({ id, name, color }) => {
                const stats = AIAnalytics.strategyPerformance[id] || { wins: 0, losses: 0, total: 0, profit: 0 };
                const winRate = stats.total > 0 ? (stats.wins / stats.total) * 100 : 0;
                const profitStr = stats.profit >= 0 ? `+${stats.profit}` : stats.profit;
                const profitColor = stats.profit >= 0 ? 'text-success' : 'text-danger';
                
                html += `
                    <div>
                        <div class="flex justify-between mb-1">
                            <span class="text-gray-600">${name}</span>
                            <span class="font-medium ${profitColor}">${winRate.toFixed(1)}% (${profitStr})</span>
                        </div>
                        <div class="w-full bg-gray-200 rounded-full h-1.5">
                            <div class="${color} h-1.5 rounded-full" style="width: ${winRate}%"></div>
                        </div>
                        <div class="text-xs text-gray-500 mt-1">
                            投注 ${stats.total} 次 (胜 ${stats.wins} / 负 ${stats.losses})
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            panel.innerHTML = html;
        }

        // 策略分析逻辑
        function shouldPlaceBet(item) {
            if (!item.optionsList || item.optionsList.length === 0) {
                Logger.warning(`项目 #${item.id} 没有可选项，不参与投注`, true);
                return false;
            }
            
            const currentStrategy = CONFIG.state.betStrategy === "auto" 
                ? AIAnalytics.currentStrategy || "higher_odds"
                : CONFIG.state.betStrategy;
            
            switch (currentStrategy) {
                case "larger":
                    const isLargerEligible = item.optionsList.length <= 3;
                    Logger.info(`项目 #${item.id} 押大策略检查: ${isLargerEligible ? '通过' : '不通过'} (选项数量: ${item.optionsList.length})`, true);
                    return isLargerEligible;
                case "smaller":
                    const isSmallerEligible = item.optionsList.length <= 3;
                    Logger.info(`项目 #${item.id} 押小策略检查: ${isSmallerEligible ? '通过' : '不通过'} (选项数量: ${item.optionsList.length})`, true);
                    return isSmallerEligible;
                case "follow":
                    Logger.info(`项目 #${item.id} 跟随策略检查: 通过`, true);
                    return true;
                case "higher_odds":
                    const highestOption = getHighestOddsOption(item);
                    const meetsThreshold = highestOption && parseFloat(highestOption.odds) >= 1.0;
                    Logger.info(`项目 #${item.id} 高赔率策略检查: ${meetsThreshold ? '通过' : '不通过'} (最高赔率: ${highestOption?.odds || 'N/A'})`, true);
                    return meetsThreshold;
                case "ai_prediction":
                    const aiPrediction = AIAnalytics.predictionCache[item.id];
                    const meetsConfidence = aiPrediction && 
                                           (aiPrediction.confidence * 100) >= CONFIG.state.minConfidenceThreshold;
                    Logger.info(`项目 #${item.id} AI预测策略检查: ${meetsConfidence ? '通过' : '不通过'} (置信度: ${aiPrediction ? (aiPrediction.confidence * 100).toFixed(1) : 'N/A'}%)`, true);
                    return meetsConfidence;
                default:
                    return false;
            }
        }

        // 计算投注金额
        function calculateBetAmount(betItem, selectedOption) {
            if (!selectedOption) return CONFIG.state.baseAmount;
            
            if (!CONFIG.state.kellyCriterionEnabled) {
                if (CONFIG.state.amountRange <= 0) return CONFIG.state.baseAmount;
                const randomOffset = Math.floor(Math.random() * (CONFIG.state.amountRange * 2 + 1)) - CONFIG.state.amountRange;
                return Math.max(CONFIG.state.baseAmount + randomOffset, 100);
            }
            
            try {
                let p = 0.5;
                const aiPrediction = AIAnalytics.predictionCache[betItem.id];
                if (aiPrediction && selectedOption.text.includes(aiPrediction.prediction)) {
                    p = aiPrediction.confidence;
                }
                
                const odds = parseFloat(selectedOption.odds);
                const b = odds - 1;
                
                // 处理赔率为1的情况（避免除以0）
                if (b === 0) {
                    Logger.warning(`赔率为1，无法使用凯利公式，使用基础金额`);
                    return CONFIG.state.baseAmount;
                }
                
                const q = 1 - p;
                let f = (b * p - q) / b;
                f = Math.max(0, Math.min(1, f));
                
                const maxRatio = CONFIG.state.maxBetRatio / 100;
                f = Math.min(f, maxRatio);
                
                const betAmount = Math.round(CONFIG.state.totalFund * f);
                const finalAmount = Math.max(betAmount, 100);
                
                Logger.info(`凯利公式计算: 胜率=${(p*100).toFixed(1)}%, 赔率=${odds}, 比例=${(f*100).toFixed(1)}%, 金额=${finalAmount}`, true);
                
                return finalAmount;
            } catch (e) {
                Logger.error(`凯利公式计算失败: ${e.message}，使用基础金额`, true);
                return CONFIG.state.baseAmount;
            }
        }

        // 核心投注逻辑函数（补全闭合）
        async function placeCoreBet(betItem) {
            updateLastActivity();
            try {
                Logger.info(`开始为项目 #${betItem.id} 下注，策略: ${betItem.strategy}, 金额: ${betItem.betAmount}`);
                
                let choices = [];
                let myBonuses = [];
                let currentOdds = 0;
                let profit = 0;

                if (betItem.strategy === "higher_odds" || betItem.strategy === "ai_prediction") {
                    const freshBetItem = CONFIG.state.availableBets.find(item => item.id === betItem.id);
                    if (!freshBetItem) {
                        Logger.error(`项目 #${betItem.id} 已失效，取消投注`);
                        return false;
                    }
                    
                    const aiPrediction = AIAnalytics.predictionCache[betItem.id];
                    let selectedOption;
                    
                    if (aiPrediction && CONFIG.state.aiPredictionEnabled && betItem.strategy === "ai_prediction") {
                        selectedOption = freshBetItem.optionsList.find(opt => 
                            opt.text.includes(aiPrediction.prediction)
                        );
                        Logger.info(`使用AI预测结果投注: ${aiPrediction.prediction} (可信度: ${(aiPrediction.confidence * 100).toFixed(1)}%)`, true);
                    }
                    
                    if (!selectedOption) {
                        selectedOption = getHighestOddsOption(freshBetItem);
                    }
                    
                    if (!selectedOption) {
                        Logger.error(`项目 #${betItem.id} 没有找到有效选项`);
                        return false;
                    }
                    
                    currentOdds = parseFloat(selectedOption.odds);
                    choices = [selectedOption.id];
                    myBonuses = [betItem.betAmount];
                    profit = Math.round(betItem.betAmount * (currentOdds - 1));
                    Logger.info(`投注: 选项 ${selectedOption.text} (赔率: ${selectedOption.odds}), 金额 ${myBonuses[0]}, 预期利润 ${profit}`, true);
                } // 补全高赔率/AI策略代码块闭合
                else if (betItem.strategy === "larger") {
                    const largerOptions = await getLargerOptions(betItem.id);
                    if (largerOptions.length === 0) {
                        Logger.error(`项目 #${betItem.id} 没有合适的押大选项`);
                        return false;
                    }
                    
                    choices = largerOptions;
                    myBonuses = largerOptions.map(() => betItem.betAmount);
                    Logger.info(`押大投注: 选择 ${largerOptions.length} 个选项, 总金额 ${myBonuses.reduce((a, b) => a + b, 0)}`, true);
                }
                else if (betItem.strategy === "smaller") {
                    const smallerOptions = await getSmallerOptions(betItem.id);
                    if (smallerOptions.length === 0) {
                        Logger.error(`项目 #${betItem.id} 没有合适的押小选项`);
                        return false;
                    }
                    
                    choices = smallerOptions;
                    myBonuses = smallerOptions.map(() => betItem.betAmount);
                    Logger.info(`押小投注: 选择 ${smallerOptions.length} 个选项, 总金额 ${myBonuses.reduce((a, b) => a + b, 0)}`, true);
                }
                else {
                    Logger.error(`未知策略: ${betItem.strategy}`);
                    return false;
                }

                let allSuccess = true;
                for (let i = 0; i < choices.length; i++) {
                    const optId = choices[i];
                    const bonus = myBonuses[i];
                    
                    try {
                        const url = `${CONFIG.mainHost}/${CONFIG.apis.betgameOdds
                            .replace('{optId}', optId)
                            .replace('{bonus}', bonus)}`;
                        
                        const result = await request(url);
                        
                        const isSuccess = result.code === 0 || 
                                          result.code === 1 ||
                                          (result.msg && (result.msg.includes("成功") || result.msg.includes("已下注") || result.msg.includes("投注成功")));
                        
                        if (!isSuccess) {
                            Logger.error(`投注失败: ${result.msg || '未知错误'} (选项: ${optId})`);
                            allSuccess = false;
                            continue;
                        }
                        
                        Logger.info(`投注成功: 项目 #${betItem.id}, 选项 ${optId}, 金额 ${bonus}`);
                        
                        if (!GlobalInfo.bet_mask[betItem.id]) {
                            GlobalInfo.bet_mask[betItem.id] = [];
                        }
                        GlobalInfo.bet_mask[betItem.id].push(optId);
                    }
                    catch (e) {
                        Logger.warning(`主服务器投注失败，尝试备用服务器... (选项: ${optId})`);
                        try {
                            const url = `${CONFIG.testHost}/${CONFIG.apis.betgameOdds
                                .replace('{optId}', optId)
                                .replace('{bonus}', bonus)}`;
                            
                            const result = await request(url);
                            
                            const isSuccess = result.code === 0 || 
                                              result.code === 1 ||
                                              (result.msg && (result.msg.includes("成功") || result.msg.includes("已下注") || result.msg.includes("投注成功")));
                            
                            if (!isSuccess) {
                                Logger.error(`备用服务器 - 投注失败: ${result.msg || '未知错误'} (选项: ${optId})`);
                                allSuccess = false;
                                continue;
                            }
                            
                            Logger.info(`备用服务器 - 投注成功: 项目 #${betItem.id}, 选项 ${optId}, 金额 ${bonus}`);
                            
                            if (!GlobalInfo.bet_mask[betItem.id]) {
                                GlobalInfo.bet_mask[betItem.id] = [];
                            }
                            GlobalInfo.bet_mask[betItem.id].push(optId);
                        }
                        catch (e2) {
                            Logger.error(`投注请求失败: ${e2.message} (选项: ${optId})`);
                            allSuccess = false;
                        }
                    }
                }

                updateStrategyPerformance(betItem.strategy, allSuccess, profit);
                return allSuccess;
            }
            catch (e) {
                Logger.error(`投注处理失败: ${e.message}`);
                updateStrategyPerformance(betItem.strategy, false);
                return false;
            }
        }

        // 渲染可投注项目表格
        function renderBetTable() {
            const table = document.getElementById("betItemsTable");
            if (!table) return;
            
            if (CONFIG.state.availableBets.length === 0) {
                table.innerHTML = `
                    <tr>
                        <td colspan="8" class="border border-gray-200 p-8 text-center text-gray-500">
                            <div class="flex flex-col items-center">
                                <i class="fa fa-inbox text-3xl mb-2 text-gray-300"></i>
                                <span>暂无可投注项目</span>
                            </div>
                        </td>
                    </tr>
                `;
                return;
            }
            
            let html = `
                <thead>
                    <tr class="bg-gray-50">
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider rounded-tl-lg">ID</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">赛事</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">选项</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">结束时间</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">AI预测</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">操作</th>
                    </tr>
                </thead>
                <tbody class="bg-white divide-y divide-gray-200">
            `;
            
            CONFIG.state.availableBets.forEach(bet => {
                const isMasked = GlobalInfo.bet_mask[bet.id] && GlobalInfo.bet_mask[bet.id].length > 0;
                const aiPrediction = AIAnalytics.predictionCache[bet.id];
                
                html += `
                    <tr class="table-hover-row ${isMasked ? 'bg-gray-50 opacity-70' : ''}">
                        <td class="px-4 py-3 whitespace-nowrap text-sm font-medium text-gray-900">${bet.id}</td>
                        <td class="px-4 py-3 text-sm text-gray-700">
                            <div class="font-medium">${bet.heading}</div>
                            <div class="text-xs text-gray-500">${bet.undertext || ''}</div>
                        </td>
                        <td class="px-4 py-3 text-sm">
                            <ul class="space-y-1">
                                ${bet.optionsList.map(opt => `
                                    <li class="${parseFloat(opt.odds) === getHighestOddsOption(bet)?.odds ? 'odds-highlight text-primary' : ''}">
                                        ${opt.text}: <span>${opt.odds}</span>
                                        ${GlobalInfo.bet_mask[bet.id]?.includes(opt.id) ? '<i class="fa fa-check text-success ml-1"></i>' : ''}
                                    </li>
                                `).join('')}
                            </ul>
                        </td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-700">
                            ${new Date(bet.endtime).toLocaleString('zh-CN')}
                        </td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm">
                            ${aiPrediction ? `
                                <div class="flex items-center">
                                    <span>${aiPrediction.prediction}</span>
                                    <span class="ml-2 px-1.5 py-0.5 rounded text-xs confidence-${aiPrediction.confidenceLevel}">
                                        ${aiPrediction.confidenceLevel} (${(aiPrediction.confidence * 100).toFixed(1)}%)
                                    </span>
                                </div>
                            ` : '<span class="text-gray-400">-</span>'}
                        </td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm font-medium">
                            ${isMasked ? (
                                '<span class="text-success"><i class="fa fa-check mr-1"></i>已投注</span>'
                            ) : (
                                `<button onclick="manualPlaceBet('${bet.id}')" class="text-primary hover:text-primary/80 transition ${!isServiceRunning ? 'opacity-50 cursor-not-allowed' : ''}" ${!isServiceRunning ? 'disabled' : ''}>
                                    <i class="fa fa-plus-circle mr-1"></i>投注
                                </button>`
                            )}
                        </td>
                    </tr>
                `;
            });
            
            html += `</tbody>`;
            table.innerHTML = html;
        }

        // 渲染待投注项目表格
        function renderPendingBetsTable() {
            const table = document.getElementById("pendingBetsTable");
            if (!table) return;
            
            if (pendingBets.length === 0) {
                table.innerHTML = `
                    <tr>
                        <td colspan="8" class="border border-gray-200 p-8 text-center text-gray-500">
                            <div class="flex flex-col items-center">
                                <i class="fa fa-hourglass-o text-3xl mb-2 text-gray-300"></i>
                                <span>暂无待投注项目</span>
                            </div>
                        </td>
                    </tr>
                `;
                return;
            }
            
            let html = `
                <thead>
                    <tr class="bg-gray-50">
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider rounded-tl-lg">ID</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">赛事</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">投注选项</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">投注时间</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">金额</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">策略</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">AI预测</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider rounded-tr-lg">状态</th>
                    </tr>
                </thead>
                <tbody class="bg-white divide-y divide-gray-200">
            `;
            
            pendingBets.forEach(bet => {
                const now = new Date();
                const timeDiff = bet.betTime - now;
                let timeLeftText = '';
                
                if (timeDiff > 0) {
                    const seconds = Math.ceil(timeDiff / 1000);
                    timeLeftText = `<span class="text-xs text-gray-500">(${seconds}秒后)</span>`;
                }
                
                let statusClass = '';
                switch (bet.status) {
                    case "等待中":
                        statusClass = "text-warning";
                        break;
                    case "处理中":
                        statusClass = "text-primary";
                        break;
                    case "已完成":
                        statusClass = "text-success";
                        break;
                    case "失败":
                        statusClass = "text-danger";
                        break;
                }
                
                html += `
                    <tr class="table-hover-row">
                        <td class="px-4 py-3 whitespace-nowrap text-sm font-medium text-gray-900">${bet.id}</td>
                        <td class="px-4 py-3 text-sm text-gray-700">
                            <div class="font-medium">${bet.heading}</div>
                            <div class="text-xs text-gray-500">${bet.undertext || ''}</div>
                        </td>
                        <td class="px-4 py-3 text-sm text-gray-700">
                            ${bet.highestOddsTeam} <span class="text-primary">(${bet.highestOdds})</span>
                        </td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-700">
                            ${new Date(bet.betTime).toLocaleString('zh-CN')}
                            ${timeLeftText}
                        </td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-700">
                            ${bet.betAmount}
                        </td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm">
                            <span class="strategy-badge ${bet.strategy === 'ai_prediction' ? 'bg-purple/10 text-purple' : 'bg-primary/10 text-primary'}">
                                ${getStrategyDisplayName(bet.strategy)}
                            </span>
                        </td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm">
                            ${bet.aiPrediction ? `
                                <span class="confidence-${bet.aiPredictionLevel} px-1.5 py-0.5 rounded text-xs">
                                    ${bet.aiPrediction}
                                </span>
                            ` : '-'}
                        </td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm font-medium ${statusClass}">
                            ${bet.status === "处理中" ? `<i class="fa fa-spinner fa-spin mr-1"></i>${bet.status}` : bet.status}
                        </td>
                    </tr>
                `;
            });
            
            html += `</tbody>`;
            table.innerHTML = html;
        }

        // 获取策略显示名称
        function getStrategyDisplayName(strategy) {
            const names = {
                'higher_odds': '高赔率',
                'ai_prediction': 'AI预测',
                'follow': '跟随',
                'larger': '押大',
                'smaller': '押小',
                'auto': '自动'
            };
            return names[strategy] || strategy;
        }

        // 手动投注（含AI置信度提示）
        async function manualPlaceBet(betId) {
            if (!isServiceRunning) {
                alert("请先启动服务");
                return;
            }
            
            const betItem = CONFIG.state.availableBets.find(item => item.id === betId);
            if (!betItem) {
                Logger.error(`项目 #${betId} 不存在`);
                return;
            }
            
            if (GlobalInfo.bet_mask[betId] && GlobalInfo.bet_mask[betId].length > 0) {
                Logger.warning(`项目 #${betId} 已投注`);
                return;
            }
            
            if (!shouldPlaceBet(betItem)) {
                Logger.warning(`项目 #${betId} 不符合投注条件`);
                return;
            }
            
            // AI策略下提示置信度
            const currentStrategy = CONFIG.state.betStrategy === "auto" 
                ? AIAnalytics.currentStrategy || "higher_odds"
                : CONFIG.state.betStrategy;
            const aiPrediction = AIAnalytics.predictionCache[betItem.id];
            if (currentStrategy === "ai_prediction" && aiPrediction) {
                const confirmBet = confirm(`当前AI预测置信度为 ${(aiPrediction.confidence * 100).toFixed(1)}%（等级：${aiPrediction.confidenceLevel}），确定继续投注吗？`);
                if (!confirmBet) {
                    return;
                }
            }
            
            const selectedOption = getHighestOddsOption(betItem);
            const betAmount = calculateBetAmount(betItem, selectedOption);
            
            const manualBet = {
                ...betItem,
                id: betId,
                betTime: new Date(),
                betAmount,
                strategy: currentStrategy,
                status: "处理中",
                highestOddsTeam: selectedOption ? selectedOption.text : 'N/A',
                highestOdds: selectedOption ? parseFloat(selectedOption.odds) : 0,
                ratioValue: 0,
                recordedOdds: 0
            };
            
            pendingBets.unshift(manualBet);
            renderPendingBetsTable();
            
            const success = await placeCoreBet(manualBet);
            
            const index = pendingBets.findIndex(b => b.id === betId && b.status === "处理中");
            if (index !== -1) {
                pendingBets[index].status = success ? "已完成" : "失败";
                renderPendingBetsTable();
            }
            
            if (success) {
                Logger.info(`手动投注成功，3秒后自动刷新...`);
                setTimeout(() => loadBetItems(), 3000);
            }
        }

        // 开始服务
        async function startService() {
            if (isServiceRunning) return;
            
            Logger.info("正在启动服务...");
            
            const apiValid = await verifyApiKey();
            if (!apiValid) {
                Logger.error("API Key验证失败，服务启动失败");
                return;
            }
            
            if (CONFIG.state.aiPredictionEnabled) {
                await initAIModel();
            }
            
            document.getElementById("serviceStatusIndicator").className = "inline-block w-3 h-3 rounded-full bg-success mr-2";
            document.getElementById("serviceStatusText").textContent = "服务运行中";
            document.getElementById("startServiceBtn").disabled = true;
            document.getElementById("startServiceBtn").className = "flex-1 bg-success hover:bg-success/90 text-white px-4 py-2 rounded-lg transition hover-lift opacity-50 cursor-not-allowed";
            document.getElementById("stopServiceBtn").disabled = false;
            document.getElementById("stopServiceBtn").className = "flex-1 bg-danger hover:bg-danger/90 text-white px-4 py-2 rounded-lg transition hover-lift";
            
            await loadBetItems();
            startBetCheckTimer();
            
            if (CONFIG.state.autoRefresh) {
                startAutoRefresh();
            }
            
            startScheduleCheckers();
            isServiceRunning = true;
            Logger.info("服务启动成功");
        }

        // 停止服务
        function stopService() {
            if (!isServiceRunning) return;
            
            Logger.info("正在停止服务...");
            
            stopAutoRefresh();
            stopBetCheckTimer();
            stopAllFollowChecks();
            stopScheduleCheckers();
            
            document.getElementById("serviceStatusIndicator").className = "inline-block w-3 h-3 rounded-full bg-gray-400 mr-2";
            document.getElementById("serviceStatusText").textContent = "服务未运行";
            document.getElementById("startServiceBtn").disabled = false;
            document.getElementById("startServiceBtn").className = "flex-1 bg-success hover:bg-success/90 text-white px-4 py-2 rounded-lg transition hover-lift flex items-center justify-center";
            document.getElementById("stopServiceBtn").disabled = true;
            document.getElementById("stopServiceBtn").className = "flex-1 bg-danger hover:bg-danger/90 text-white px-4 py-2 rounded-lg transition hover-lift opacity-50 cursor-not-allowed";
            
            isServiceRunning = false;
            Logger.info("服务已停止");
        }

        // 启动投注检查定时器
        function startBetCheckTimer() {
            if (betCheckTimer) {
                clearInterval(betCheckTimer);
            }
            
            const checkInterval = CONFIG.state.checkInterval * 1000;
            Logger.info(`启动投注检查定时器 (间隔: ${checkInterval}ms)`, true);
            
            betCheckTimer = setInterval(() => {
                if (!isServiceRunning || !isPageVisible) return;
                
                const now = new Date();
                const betsToProcess = pendingBets.filter(bet => 
                    bet.status === "等待中" && bet.betTime <= now
                );
                
                if (betsToProcess.length > 0) {
                    Logger.info(`检测到 ${betsToProcess.length} 个需要处理的投注`, true);
                    
                    betsToProcess.forEach(bet => {
                        const index = pendingBets.findIndex(b => b.id === bet.id && b.status === "等待中");
                        if (index !== -1) {
                            pendingBets[index].status = "处理中";
                            renderPendingBetsTable();
                            
                            placeCoreBet(bet).then(success => {
                                const updateIndex = pendingBets.findIndex(b => b.id === bet.id && b.status === "处理中");
                                if (updateIndex !== -1) {
                                    pendingBets[updateIndex].status = success ? "已完成" : "失败";
                                    renderPendingBetsTable();
                                }
                                
                                if (success) {
                                    Logger.info(`自动投注完成，3秒后自动刷新...`);
                                    setTimeout(() => loadBetItems(), 3000);
                                }
                            });
                        }
                    });
                }
                
                const nowTime = now.getTime();
                pendingBets = pendingBets.filter(bet => {
                    const endTime = new Date(bet.endtime).getTime();
                    const isExpired = endTime + CONFIG.state.toleranceSeconds * 1000 < nowTime;
                    if (isExpired) {
                        Logger.info(`清理过期投注记录 #${bet.id}`, true);
                    }
                    return !isExpired;
                });
                
                renderPendingBetsTable();
            }, checkInterval);
        }

        // 停止投注检查定时器
        function stopBetCheckTimer() {
            if (betCheckTimer) {
                clearInterval(betCheckTimer);
                betCheckTimer = null;
                Logger.info("已停止投注检查定时器", true);
            }
        }

        // 停止所有跟随检查
        function stopAllFollowChecks() {
            Object.keys(followCheckTimers).forEach(gameId => {
                clearInterval(followCheckTimers[gameId]);
            });
            followCheckTimers = {};
            Logger.info("已停止所有跟随检查定时器", true);
        }

        // 启动自动刷新
        function startAutoRefresh() {
            if (autoRefreshTimer) {
                clearInterval(autoRefreshTimer);
            }
            
            const refreshMs = CONFIG.state.refreshInterval * 1000;
            Logger.info(`启动自动刷新 (间隔: ${refreshMs}ms)`, true);
            
            refreshCycleStartTime = new Date().getTime();
            updateRefreshIntervalDisplay();
            
            autoRefreshTimer = setInterval(() => {
                if (!isServiceRunning || !isPageVisible) return;
                loadBetItems();
            }, refreshMs);
            
            document.getElementById("autoRefreshBtn").innerHTML = '<i class="fa fa-refresh mr-1"></i> 关闭自动刷新';
            document.getElementById("autoRefreshBtn").onclick = toggleAutoRefresh;
        }

        // 停止自动刷新
        function stopAutoRefresh() {
            if (autoRefreshTimer) {
                clearInterval(autoRefreshTimer);
                autoRefreshTimer = null;
                Logger.info("已停止自动刷新", true);
            }
            
            document.getElementById("autoRefreshBtn").innerHTML = '<i class="fa fa-refresh mr-1"></i> 开启自动刷新';
            document.getElementById("autoRefreshBtn").onclick = toggleAutoRefresh;
        }

        // 切换自动刷新状态
        function toggleAutoRefresh() {
            CONFIG.state.autoRefresh = !CONFIG.state.autoRefresh;
            
            if (CONFIG.state.autoRefresh && isServiceRunning) {
                startAutoRefresh();
            } else {
                stopAutoRefresh();
            }
        }

        // 手动刷新
        async function manualRefresh() {
            if (!isServiceRunning) {
                alert("请先启动服务");
                return;
            }
            
            Logger.info("执行手动刷新...");
            await loadBetItems();
        }

        // 更新刷新间隔显示
        function updateRefreshIntervalDisplay() {
            if (!refreshCycleStartTime || !CONFIG.state.autoRefresh) {
                document.getElementById("refreshIntervalDisplay").textContent = "00:00:30.000";
                return;
            }
            
            const now = new Date().getTime();
            const elapsed = now - refreshCycleStartTime;
            const remaining = Math.max(0, CONFIG.state.refreshInterval * 1000 - elapsed);
            
            const hours = Math.floor(remaining / 3600000);
            const minutes = Math.floor((remaining % 3600000) / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            const milliseconds = Math.floor(remaining % 1000);
            
            const display = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
            document.getElementById("refreshIntervalDisplay").textContent = display;
            
            if (countdownTimer) {
                cancelAnimationFrame(countdownTimer);
            }
            
            countdownTimer = requestAnimationFrame(updateRefreshIntervalDisplay);
        }

        // 重置刷新周期
        function resetRefreshCycle() {
            refreshCycleStartTime = new Date().getTime();
        }

        // 启动定时任务检查器
        function startScheduleCheckers() {
            stopScheduleCheckers();
            
            if (CONFIG.state.schedule1Enabled) {
                scheduleTimers.check1 = setInterval(checkSchedule1, 60000);
                Logger.info(`启动定时任务1 (${CONFIG.state.schedule1StartTime} - ${CONFIG.state.schedule1StopTime})`, true);
                checkSchedule1();
            }
            
            if (CONFIG.state.schedule2Enabled) {
                scheduleTimers.check2 = setInterval(checkSchedule2, 60000);
                Logger.info(`启动定时任务2 (${CONFIG.state.schedule2StartTime} - ${CONFIG.state.schedule2StopTime})`, true);
                checkSchedule2();
            }
        }

        // 停止定时任务检查器
        function stopScheduleCheckers() {
            if (scheduleTimers.check1) {
                clearInterval(scheduleTimers.check1);
                scheduleTimers.check1 = null;
            }
            
            if (scheduleTimers.check2) {
                clearInterval(scheduleTimers.check2);
                scheduleTimers.check2 = null;
            }
            
            Logger.info("已停止所有定时任务检查器", true);
        }

        // 检查定时任务1
        function checkSchedule1() {
            checkSchedule(
                CONFIG.state.schedule1StartTime,
                CONFIG.state.schedule1StopTime,
                "定时任务1"
            );
        }

        // 检查定时任务2
        function checkSchedule2() {
            checkSchedule(
                CONFIG.state.schedule2StartTime,
                CONFIG.state.schedule2StopTime,
                "定时任务2"
            );
        }

        // 检查定时任务是否在运行时间内
        function checkSchedule(startTime, stopTime, name) {
            const now = new Date();
            const currentTime = now.getHours() * 60 + now.getMinutes();
            
            const [startHours, startMinutes] = startTime.split(':').map(Number);
            const startTotalMinutes = startHours * 60 + startMinutes;
            
            const [stopHours, stopMinutes] = stopTime.split(':').map(Number);
            const stopTotalMinutes = stopHours * 60 + stopMinutes;
            
            let isInSchedule = false;
            
            if (startTotalMinutes <= stopTotalMinutes) {
                isInSchedule = currentTime >= startTotalMinutes && currentTime <= stopTotalMinutes;
            } else {
                isInSchedule = currentTime >= startTotalMinutes || currentTime <= stopTotalMinutes;
            }
            
            if (isInSchedule && !isServiceRunning) {
                Logger.info(`${name} 时间范围内，自动启动服务`);
                startService();
            } else if (!isInSchedule && isServiceRunning) {
                Logger.info(`超出 ${name} 时间范围，自动停止服务`);
                stopService();
            }
        }

        // 切换日志弹窗
        function toggleLogModal() {
            logModalVisible = !logModalVisible;
            const modal = document.getElementById('logModal');
            
            if (logModalVisible) {
                modal.classList.remove('hidden');
                Logger.render();
            } else {
                modal.classList.add('hidden');
            }
        }

        // 保存配置
        function saveParameters() {
            try {
                CONFIG.state.targetUserId = document.getElementById("targetUserIdInput").value;
                CONFIG.state.advanceSeconds = parseInt(document.getElementById("advanceSecondsInput").value) || 3;
                CONFIG.state.toleranceSeconds = parseInt(document.getElementById("toleranceSecondsInput").value) || 1;
                CONFIG.state.betStrategy = document.getElementById("betStrategySelect").value;
                CONFIG.state.checkInterval = parseFloat(document.getElementById("checkIntervalInput").value) || 2;
                CONFIG.state.detailedLogMode = document.getElementById("detailedLogModeCheckbox").checked;
                Logger.toggleDetailedMode(CONFIG.state.detailedLogMode);
                CONFIG.state.pendingFilter = document.getElementById("pendingFilterSelect").value;
                CONFIG.state.followCheckInterval = parseInt(document.getElementById("followCheckIntervalInput").value) || 500;
                
                CONFIG.state.totalFund = parseInt(document.getElementById("totalFundInput").value) || 50000;
                CONFIG.state.baseAmount = parseInt(document.getElementById("baseAmountInput").value) || 1000;
                CONFIG.state.maxBetRatio = parseInt(document.getElementById("maxBetRatioInput").value) || 10;
                CONFIG.state.kellyCriterionEnabled = document.getElementById("kellyCriterionEnabledCheckbox").checked;
                
                CONFIG.state.aiPredictionEnabled = document.getElementById("aiPredictionEnabledCheckbox").checked;
                CONFIG.state.minConfidenceThreshold = parseInt(document.getElementById("minConfidenceThresholdInput").value) || 60;
                CONFIG.state.oddsVolatilitySensitivity = document.getElementById("oddsVolatilitySensitivityInput").value;
                CONFIG.state.dynamicPredictionEnabled = document.getElementById("dynamicPredictionEnabledCheckbox").checked;
                
                const refreshHours = parseInt(document.getElementById("refreshHoursInput").value) || 0;
                const refreshMinutes = parseInt(document.getElementById("refreshMinutesInput").value) || 0;
                const refreshSeconds = parseInt(document.getElementById("refreshSecondsInput").value) || 30;
                CONFIG.state.refreshInterval = refreshHours * 3600 + refreshMinutes * 60 + refreshSeconds;
                
                CONFIG.state.schedule1Enabled = document.getElementById("schedule1EnabledCheckbox").checked;
                CONFIG.state.schedule1StartTime = document.getElementById("schedule1StartTimeInput").value;
                CONFIG.state.schedule1StopTime = document.getElementById("schedule1StopTimeInput").value;
                CONFIG.state.schedule2Enabled = document.getElementById("schedule2EnabledCheckbox").checked;
                CONFIG.state.schedule2StartTime = document.getElementById("schedule2StartTimeInput").value;
                CONFIG.state.schedule2StopTime = document.getElementById("schedule2StopTimeInput").value;
                
                if (isServiceRunning) {
                    stopAutoRefresh();
                    startAutoRefresh();
                    stopBetCheckTimer();
                    startBetCheckTimer();
                    stopScheduleCheckers();
                    startScheduleCheckers();
                }
                
                Logger.info("配置已保存");
                alert("配置已保存");
            } catch (e) {
                Logger.error(`保存配置失败: ${e.message}`);
                alert("保存配置失败，请检查输入");
            }
        }

        // 更新最后活动时间
        function updateLastActivity() {
            lastActivityTime = new Date().getTime();
        }

        // 页面加载完成后初始化（含API Key提示）
        document.addEventListener('DOMContentLoaded', function() {
            // 提示用户替换体育数据API Key
            if (CONFIG.sportsApiKey === "your_sports_api_key") {
                alert("提示：请在代码 CONFIG 对象中替换 sportsApiKey 为真实的体育数据API Key（如SportsData.io的Key），否则AI预测模块将使用模拟数据！");
            }
            
            renderBetTable();
            renderPendingBetsTable();
            updateRefreshIntervalDisplay();
            Logger.info("系统初始化完成");
            
            document.addEventListener('visibilitychange', function() {
                isPageVisible = !document.hidden;
                Logger.info(`页面${isPageVisible ? '可见' : '不可见'}`);
            });
            
            updateStrategyPerformancePanel();
        });
    </script>
</body>
</html>
