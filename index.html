<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M-Team 自动投注系统</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/axios@1.6.2/dist/axios.min.js"></script>
    <script>
        // 配置Tailwind
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#165DFF',
                        secondary: '#36CFC9',
                        success: '#52C41A',
                        warning: '#FAAD14',
                        danger: '#FF4D4F',
                        dark: '#1F2937',
                        light: '#F9FAFB',
                        purple: '#7B61FF',
                        ai: '#FF7D00' // AI预测标识色
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                    boxShadow: {
                        'card': '0 4px 20px rgba(0, 0, 0, 0.06)',
                        'card-hover': '0 8px 30px rgba(0, 0, 0, 0.12)',
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .card-shadow {
                box-shadow: var(--tw-shadow-card);
            }
            .hover-lift {
                transition: transform 0.3s ease, box-shadow 0.3s ease;
            }
            .hover-lift:hover {
                transform: translateY(-3px);
                box-shadow: var(--tw-shadow-card-hover);
            }
            .table-hover-row:hover {
                background-color: rgba(22, 93, 255, 0.03);
            }
            .odds-highlight {
                background-color: rgba(82, 196, 26, 0.1);
                font-weight: bold;
                border-left: 3px solid #52C41A;
            }
            .ai-highlight {
                position: relative;
                padding-left: 1.5rem;
            }
            .ai-highlight::before {
                content: "AI";
                position: absolute;
                left: 0;
                color: #FF7D00;
                font-weight: bold;
                font-size: 0.8rem;
                background-color: rgba(255, 125, 0, 0.1);
                padding: 0 4px;
                border-radius: 2px;
            }
            .follower-indicator {
                position: relative;
                padding-left: 1.5rem;
            }
            .follower-indicator::before {
                content: "→";
                position: absolute;
                left: 0;
                color: #7B61FF;
                font-weight: bold;
            }
            .scrollbar-thin {
                scrollbar-width: thin;
            }
            .scrollbar-thin::-webkit-scrollbar {
                width: 4px;
                height: 4px;
            }
            .scrollbar-thin::-webkit-scrollbar-thumb {
                background-color: rgba(156, 163, 175, 0.5);
                border-radius: 2px;
            }
            .status-badge {
                padding: 2px 8px;
                border-radius: 12px;
                font-size: 0.75rem;
                font-weight: 500;
            }
            .gradient-bg {
                background: linear-gradient(135deg, #165DFF 0%, #7B61FF 100%);
            }
        }
    </style>
</head>
<body class="bg-gray-50 font-sans text-gray-800 min-h-screen">
    <!-- 顶部导航栏 -->
    <header class="sticky top-0 z-30 bg-white shadow-sm">
        <div class="container mx-auto px-4 py-3 max-w-7xl">
            <div class="flex flex-col md:flex-row justify-between items-center gap-3">
                <h1 class="text-xl md:text-2xl font-bold text-dark flex items-center">
                    <i class="fa fa-line-chart text-primary mr-2"></i>
                    M-Team 自动投注系统
                </h1>
                
                <div class="flex items-center space-x-4 w-full md:w-auto">
                    <div class="flex items-center bg-gray-100 px-3 py-1.5 rounded-lg">
                        <span id="serviceStatusIndicator" class="inline-block w-3 h-3 rounded-full bg-gray-400 mr-2"></span>
                        <span id="serviceStatusText" class="text-sm font-medium">服务未运行</span>
                    </div>
                    
                    <div class="flex gap-2 flex-1 md:flex-none">
                        <button id="startServiceBtn" onclick="startService()" class="flex-1 bg-success hover:bg-success/90 text-white px-4 py-2 rounded-lg transition hover-lift flex items-center justify-center">
                            <i class="fa fa-play mr-2"></i> 启动服务
                        </button>
                        <button id="stopServiceBtn" onclick="stopService()" class="flex-1 bg-danger hover:bg-danger/90 text-white px-4 py-2 rounded-lg transition hover-lift opacity-50 cursor-not-allowed" disabled>
                            <i class="fa fa-stop mr-2"></i> 停止服务
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="flex flex-wrap gap-2 pt-2 text-sm">
                <div class="flex items-center bg-gray-50 px-3 py-1.5 rounded-lg">
                    <span class="text-gray-600 mr-2">刷新间隔:</span>
                    <span id="refreshIntervalDisplay" class="font-mono text-primary">00:00:30.000</span>
                </div>
                
                <button id="autoRefreshBtn" onclick="toggleAutoRefresh()" class="text-primary hover:text-primary/80 flex items-center px-3 py-1.5 rounded-lg hover:bg-primary/5 transition">
                    <i class="fa fa-refresh mr-1"></i> 关闭自动刷新
                </button>
                
                <button onclick="manualRefresh()" class="text-primary hover:text-primary/80 flex items-center px-3 py-1.5 rounded-lg hover:bg-primary/5 transition">
                    <i class="fa fa-sync mr-1"></i> 手动刷新
                </button>
                
                <button onclick="toggleLogModal()" class="text-primary hover:text-primary/80 flex items-center px-3 py-1.5 rounded-lg hover:bg-primary/5 transition ml-auto">
                    <i class="fa fa-list-alt mr-1"></i> 查看日志
                </button>
            </div>
        </div>
    </header>

    <main class="container mx-auto px-4 py-6 max-w-7xl">
        <!-- 数据概览卡片 -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            <div class="bg-white rounded-xl card-shadow p-4 hover-lift">
                <div class="flex items-center justify-between mb-2">
                    <h3 class="text-sm font-medium text-gray-500">可投注项目</h3>
                    <i class="fa fa-list-ol text-primary"></i>
                </div>
                <p id="availableBetsCount" class="text-2xl font-bold">0 个</p>
                <p class="text-xs text-gray-400 mt-1">实时可投注赛事数量</p>
            </div>
            
            <div class="bg-white rounded-xl card-shadow p-4 hover-lift">
                <div class="flex items-center justify-between mb-2">
                    <h3 class="text-sm font-medium text-gray-500">待投注项目</h3>
                    <i class="fa fa-clock-o text-warning"></i>
                </div>
                <p id="pendingBetsCount" class="text-2xl font-bold">0 个</p>
                <p class="text-xs text-gray-400 mt-1">等待执行投注任务</p>
            </div>
            
            <div class="bg-white rounded-xl card-shadow p-4 hover-lift">
                <div class="flex items-center justify-between mb-2">
                    <h3 class="text-sm font-medium text-gray-500">AI预测准确率</h3>
                    <i class="fa fa-brain text-ai"></i>
                </div>
                <p id="aiAccuracy" class="text-2xl font-bold">--%</p>
                <p class="text-xs text-gray-400 mt-1">基于历史数据统计</p>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- 主内容区 -->
            <div class="lg:col-span-2 space-y-6">
                <!-- 可投注项目 -->
                <div class="bg-white rounded-xl card-shadow overflow-hidden transition-all duration-300 hover-lift">
                    <div class="bg-gray-50 px-5 py-4 border-b border-gray-100 flex justify-between items-center">
                        <h2 class="text-lg font-semibold flex items-center">
                            <i class="fa fa-list-ol text-primary mr-2"></i> 可投注项目
                            <span id="availableBetsCount2" class="ml-2 text-sm font-normal text-gray-500">0 个项目</span>
                        </h2>
                        <div class="text-xs text-gray-500">
                            <span class="inline-block w-3 h-3 rounded-full bg-ai mr-1"></span> AI预测获胜队伍
                        </div>
                    </div>
                    <div class="p-4">
                        <div class="overflow-x-auto scrollbar-thin">
                            <table id="betItemsTable" class="min-w-full divide-y divide-gray-200">
                                <tr>
                                    <td colspan="7" class="border border-gray-200 p-8 text-center text-gray-500">
                                        <div class="flex flex-col items-center">
                                            <i class="fa fa-inbox text-3xl mb-2 text-gray-300"></i>
                                            <span>请启动服务加载数据</span>
                                        </div>
                                    </td>
                                </tr>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- 待投注项目 -->
                <div class="bg-white rounded-xl card-shadow overflow-hidden transition-all duration-300 hover-lift">
                    <div class="bg-gray-50 px-5 py-4 border-b border-gray-100">
                        <h2 class="text-lg font-semibold flex items-center">
                            <i class="fa fa-clock-o text-primary mr-2"></i> 待投注项目
                            <span id="pendingBetsCount2" class="ml-2 text-sm font-normal text-gray-500">0 个项目</span>
                        </h2>
                    </div>
                    <div class="p-4">
                        <div class="overflow-x-auto scrollbar-thin">
                            <table id="pendingBetsTable" class="min-w-full divide-y divide-gray-200">
                                <tr>
                                    <td colspan="8" class="border border-gray-200 p-8 text-center text-gray-500">
                                        <div class="flex flex-col items-center">
                                            <i class="fa fa-hourglass-o text-3xl mb-2 text-gray-300"></i>
                                            <span>暂无待投注项目</span>
                                        </div>
                                    </td>
                                </tr>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- 操作日志 -->
                <div class="bg-white rounded-xl card-shadow overflow-hidden transition-all duration-300 hover-lift">
                    <div class="bg-gray-50 px-5 py-4 border-b border-gray-100">
                        <h2 class="text-lg font-semibold flex items-center">
                            <i class="fa fa-history text-primary mr-2"></i> 操作日志
                        </h2>
                    </div>
                    <div id="logPanel" class="h-48 overflow-y-auto p-4 border-t border-gray-100 text-sm scrollbar-thin"></div>
                </div>
            </div>

            <!-- 配置面板 -->
            <div class="lg:col-span-1 space-y-6">
                <!-- 基本配置 -->
                <div class="bg-white rounded-xl card-shadow overflow-hidden transition-all duration-300 hover-lift">
                    <div class="bg-gray-50 px-5 py-4 border-b border-gray-100">
                        <h2 class="text-lg font-semibold flex items-center">
                            <i class="fa fa-cog text-primary mr-2"></i> 基本配置
                        </h2>
                    </div>
                    <div class="p-5 space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">API Key</label>
                            <input type="text" id="apiKeyInput" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition" placeholder="输入API Key">
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">目标用户ID (跟随模式)</label>
                            <input type="text" id="targetUserIdInput" value="205809" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">投注策略</label>
                            <select id="betStrategySelect" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                                <option value="higher_odds">最高赔率优先</option>
                                <option value="follow">跟随目标用户</option>
                                <option value="larger">押大</option>
                                <option value="smaller">押小</option>
                            </select>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">提前下注时间 (秒)</label>
                            <input type="number" id="advanceSecondsInput" value="3" min="0" max="60" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">容忍时间 (秒)</label>
                            <input type="number" id="toleranceSecondsInput" value="10" min="0" max="300" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                        </div>
                    </div>
                </div>

                <!-- 金额设置 & 收益计算 -->
                <div class="bg-white rounded-xl card-shadow overflow-hidden transition-all duration-300 hover-lift">
                    <div class="bg-gray-50 px-5 py-4 border-b border-gray-100">
                        <h2 class="text-lg font-semibold flex items-center">
                            <i class="fa fa-money text-primary mr-2"></i> 金额设置 & 收益计算
                        </h2>
                    </div>
                    <div class="p-5 space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">基础投注金额</label>
                            <input type="number" id="baseAmountInput" value="10000" min="100" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition" oninput="calculateProfit()">
                        </div>
                        
                        <div class="bg-green-50 border border-green-100 rounded-lg p-3">
                            <label class="block text-xs font-medium text-gray-500 mb-1">预计收益计算</label>
                            <div class="flex justify-between items-center">
                                <span class="text-sm text-gray-700">基础收益:</span>
                                <span id="baseProfitDisplay" class="text-sm font-medium text-success">0</span>
                            </div>
                            <div class="flex justify-between items-center mt-1">
                                <span class="text-sm text-gray-700">收益率:</span>
                                <span id="profitRateDisplay" class="text-sm font-medium text-success">0%</span>
                            </div>
                            <div class="text-xs text-gray-400 mt-1">
                                计算公式: 投注金额 × (赔率 - 1)
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 刷新设置 -->
                <div class="bg-white rounded-xl card-shadow overflow-hidden transition-all duration-300 hover-lift">
                    <div class="bg-gray-50 px-5 py-4 border-b border-gray-100">
                        <h2 class="text-lg font-semibold flex items-center">
                            <i class="fa fa-refresh text-primary mr-2"></i> 刷新设置
                        </h2>
                    </div>
                    <div class="p-5 space-y-4">
                        <div class="grid grid-cols-3 gap-2">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">时</label>
                                <input type="number" id="refreshHoursInput" value="0" min="0" max="23" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">分</label>
                                <input type="number" id="refreshMinutesInput" value="0" min="0" max="59" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">秒</label>
                                <input type="number" id="refreshSecondsInput" value="30" min="5" max="60" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                            </div>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">检查间隔 (秒)</label>
                            <input type="number" id="checkIntervalInput" value="2" min="0.1" step="0.1" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">跟随检查间隔 (毫秒)</label>
                            <input type="number" id="followCheckIntervalInput" value="100" min="50" max="1000" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                            <p class="text-xs text-gray-500 mt-1">建议50-200ms，间隔越小响应越快</p>
                        </div>
                    </div>
                </div>

                <!-- 定时任务 -->
                <div class="bg-white rounded-xl card-shadow overflow-hidden transition-all duration-300 hover-lift">
                    <div class="bg-gray-50 px-5 py-4 border-b border-gray-100">
                        <h2 class="text-lg font-semibold flex items-center">
                            <i class="fa fa-calendar-check-o text-primary mr-2"></i> 定时任务
                        </h2>
                    </div>
                    <div class="p-5 space-y-4">
                        <div>
                            <label class="flex items-center">
                                <input type="checkbox" id="schedule1EnabledCheckbox" class="form-checkbox h-5 w-5 text-primary rounded focus:ring-primary/50">
                                <span class="ml-2 text-sm text-gray-700">启用第一组定时任务</span>
                            </label>
                            <div class="mt-2 grid grid-cols-2 gap-2 pl-7">
                                <div>
                                    <label class="block text-xs text-gray-500 mb-1">开始时间</label>
                                    <input type="time" id="schedule1StartTimeInput" value="09:00" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition text-sm">
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-500 mb-1">结束时间</label>
                                    <input type="time" id="schedule1StopTimeInput" value="23:00" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition text-sm">
                                </div>
                            </div>
                        </div>
                        
                        <div>
                            <label class="flex items-center">
                                <input type="checkbox" id="schedule2EnabledCheckbox" class="form-checkbox h-5 w-5 text-primary rounded focus:ring-primary/50">
                                <span class="ml-2 text-sm text-gray-700">启用第二组定时任务</span>
                            </label>
                            <div class="mt-2 grid grid-cols-2 gap-2 pl-7">
                                <div>
                                    <label class="block text-xs text-gray-500 mb-1">开始时间</label>
                                    <input type="time" id="schedule2StartTimeInput" value="00:00" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition text-sm">
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-500 mb-1">结束时间</label>
                                    <input type="time" id="schedule2StopTimeInput" value="06:00" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition text-sm">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 其他设置 -->
                <div class="bg-white rounded-xl card-shadow overflow-hidden transition-all duration-300 hover-lift">
                    <div class="bg-gray-50 px-5 py-4 border-b border-gray-100">
                        <h2 class="text-lg font-semibold flex items-center">
                            <i class="fa fa-filter text-primary mr-2"></i> 其他设置
                        </h2>
                    </div>
                    <div class="p-5 space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">待投注筛选</label>
                            <select id="pendingFilterSelect" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition">
                                <option value="all">全部</option>
                                <option value="highest_odds">最高赔率</option>
                                <option value="highest_amount">最高金额</option>
                                <option value="ratio_based">最佳比例</option>
                            </select>
                        </div>
                        
                        <div>
                            <label class="flex items-center">
                                <input type="checkbox" id="detailedLogModeCheckbox" class="form-checkbox h-5 w-5 text-primary rounded focus:ring-primary/50">
                                <span class="ml-2 text-sm text-gray-700">详细日志模式</span>
                            </label>
                        </div>
                        
                        <div>
                            <label class="flex items-center">
                                <input type="checkbox" id="aiPredictionEnabledCheckbox" checked class="form-checkbox h-5 w-5 text-primary rounded focus:ring-primary/50">
                                <span class="ml-2 text-sm text-gray-700">启用AI预测</span>
                            </label>
                        </div>
                        
                        <button onclick="saveParameters()" class="w-full bg-primary hover:bg-primary/90 text-white py-2.5 rounded-lg transition hover-lift">
                            保存配置
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- 日志弹窗 -->
    <div id="logModal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-xl w-full max-w-4xl max-h-[90vh] flex flex-col shadow-xl">
            <div class="p-4 border-b flex justify-between items-center">
                <h3 class="font-semibold text-lg">详细日志</h3>
                <div class="flex space-x-2">
                    <button onclick="Logger.clear()" class="text-sm text-gray-600 hover:text-gray-900 px-3 py-1 rounded hover:bg-gray-100 transition">
                        <i class="fa fa-trash mr-1"></i> 清空
                    </button>
                    <button onclick="toggleLogModal()" class="text-gray-600 hover:text-gray-900 p-1 rounded-full hover:bg-gray-100 transition">
                        <i class="fa fa-times"></i>
                    </button>
                </div>
            </div>
            <div id="logModalPanel" class="flex-1 overflow-y-auto p-4 text-sm scrollbar-thin"></div>
        </div>
    </div>

    <script>
        // 安全机制 - 防调试和防复制
        (function() {
            const antiDebug = () => {
                if (window.outerHeight - window.innerHeight > 200 || window.outerWidth - window.innerWidth > 200) {
                    document.body.innerHTML = '<div class="flex items-center justify-center h-screen bg-danger text-white text-xl">检测到非法调试行为，系统已保护</div>';
                    return;
                }
                requestAnimationFrame(antiDebug);
            };
            antiDebug();

            document.addEventListener('contextmenu', e => e.preventDefault());
            document.addEventListener('selectstart', e => e.preventDefault());
            document.addEventListener('keydown', e => {
                if (e.key === 'F12' || (e.ctrlKey && e.shiftKey && e.key === 'I')) {
                    e.preventDefault();
                    alert('禁止调试');
                }
            });
        })();

        if (typeof axios === 'undefined') {
            document.write('<script src="https://unpkg.com/axios@1.6.2/dist/axios.min.js"><\/script>');
        }

        // 字符串哈希函数，用于临时生成teamId
        String.prototype.hashCode = function() {
            let hash = 0;
            for (let i = 0; i < this.length; i++) {
                const char = this.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // 转换为32位整数
            }
            return Math.abs(hash);
        };

        // 全局变量
        let autoRefreshTimer = null;
        let betCheckTimer = null;
        let followCheckTimers = {}; // 跟随模式专用检查定时器
        let pendingBets = [];
        let isServiceRunning = false;
        let logModalVisible = false;
        let lastActivityTime = 0;
        let isPageVisible = true;
        let countdownTimer = null;
        let refreshCycleStartTime = 0; // 记录当前刷新周期的开始时间戳
        let scheduleTimers = { check1: null, check2: null }; // 定时启动/停止定时器
        
        // AI分析相关数据存储
        const AIAnalytics = {
            historicalData: {}, // 存储历史数据 {teamId: {wins, losses, total, recentScores: []}}
            predictionCache: {}, // 缓存预测结果 {gameId: {prediction, confidence}}
            accuracyStats: { correct: 0, total: 0 } // AI预测准确率统计
        };
        
        const GlobalInfo = {
            bet_mask: {},
            available_bets: [],
            my_bet_log: [],
            configs: {},
            followedBets: {}, // 记录已跟随的投注 {gameId: {optionId, amount, status}}
            // 跟随模式增强 - 预加载用户数据 & 行为分析
            targetUserCache: {}, // 缓存目标用户数据 {userId: {lastBetTime, betPattern, avgBetTimeDiff}}
            preloadTimers: {}, // 预加载定时器
            userBetBehavior: {} // 目标用户投注行为分析 {userId: {last5BetTimeDiff: []}}
        };

        // 日志系统
        const Logger = {
            logs: [],
            detailedMode: false,
            log(content, level = "INFO", detailed = false) {
                if (detailed && !this.detailedMode) return;
                
                const now = new Date().toLocaleString("zh-CN", {
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    fractionalSecondDigits: 3
                });
                const logItem = `[${now}] [${level}] ${content}`;
                this.logs.unshift(logItem);
                if (this.logs.length > 500) this.logs.pop();
                this.render();
            },
            info(content, detailed = false) { this.log(content, "INFO", detailed); },
            error(content, detailed = false) { this.log(content, "ERROR", detailed); },
            warning(content, detailed = false) { this.log(content, "WARN", detailed); },
            success(content, detailed = false) { this.log(content, "SUCCESS", detailed); }, // 新增成功日志级别
            clear() {
                this.logs = [];
                this.render();
                this.info("日志已清空");
            },
            render() {
                const mainPanel = document.getElementById('logPanel');
                if (mainPanel) {
                    mainPanel.innerHTML = this.logs.map(log => 
                        `<div class="py-1 ${log.includes('ERROR') ? 'text-danger' : log.includes('WARN') ? 'text-warning' : log.includes('SUCCESS') ? 'text-success' : ''}">${log}</div>`
                    ).join("");
                    mainPanel.scrollTop = mainPanel.scrollHeight;
                }
                
                const modalPanel = document.getElementById('logModalPanel');
                if (modalPanel) {
                    modalPanel.innerHTML = this.logs.map(log => 
                        `<div class="py-1 ${log.includes('ERROR') ? 'text-danger' : log.includes('WARN') ? 'text-warning' : log.includes('SUCCESS') ? 'text-success' : ''}">${log}</div>`
                    ).join("");
                    modalPanel.scrollTop = modalPanel.scrollHeight;
                }
            },
            toggleDetailedMode(enabled) {
                this.detailedMode = enabled;
                this.info(`详细日志模式已${enabled ? '开启' : '关闭'}`, true);
            }
        };

        // 配置
        const CONFIG = {
            mainHost: "https://api.m-team.io/api",
            testHost: "https://test2.m-team.cc/api",
            apis: {
                "get_current_bet": "bet/findBetgameList?active=LIVE&fix=0",
                "betgameOdds": "bet/betgameOdds?optId={optId}&bonus={bonus}",
                "get_details": "bet/getDetail?gameId={gameId}",
                "get_gamblers": "bet/getDetailBetList?gameId={gameId}",
                "get_my_bet_log": "bet/myCouponLog",
                "get_team_history": "team/getHistory?teamId={teamId}",
                "get_user_profile": "user/getProfile?userId={userId}" // 新增用户信息接口（预加载用）
            },
            state: {
                availableBets: [],
                autoRefresh: true,
                refreshInterval: 30,
                targetUserId: "205809",
                advanceSeconds: 3,
                toleranceSeconds: 10,
                baseAmount: 10000, // 移除随机波动范围，只保留基础金额
                betStrategy: "higher_odds",
                checkInterval: 2,
                detailedLogMode: false,
                pendingFilter: "all",
                aiPredictionEnabled: true,
                followCheckInterval: 100, // 优化为默认100ms，提升响应速度
                // 定时任务配置
                schedule1Enabled: false,
                schedule1StartTime: "09:00",
                schedule1StopTime: "23:00",
                schedule2Enabled: false,
                schedule2StartTime: "00:00",
                schedule2StopTime: "06:00",
                // 跟随模式优化配置
                followPreCheckWindow: 15, // 提前检查窗口期（秒）
                followEmergencyWindow: 5, // 紧急检查窗口期（秒）
                followPredictThreshold: 0.7 // 行为预测可信度阈值
            }
        };

        // 核心请求函数
        async function request(url, method = 'post', data = {}, retry = 1) {
            try {
                const response = await axios({
                    method,
                    url,
                    data,
                    headers: {
                        "x-api-key": document.getElementById("apiKeyInput").value || "",
                        "Content-Type": "application/json"
                    },
                    timeout: 15000
                });
                Logger.info(`请求成功: ${url}`, true);
                return response.data;
            } catch (e) {
                Logger.error(`请求失败: ${e.message} (${url})`, true);
                if (retry > 0) {
                    Logger.warning(`尝试重试请求: ${url}`, true);
                    return request(url, method, data, retry - 1);
                }
                throw new Error(`请求失败: ${e.message}`);
            }
        }

        // API验证逻辑
        async function verifyApiKey() {
            const apiKey = document.getElementById("apiKeyInput").value;
            if (!apiKey) {
                Logger.warning("请输入API Key");
                return false;
            }

            try {
                Logger.info("正在验证API Key（通过获取投注列表）...");
                const result = await request(`${CONFIG.mainHost}/${CONFIG.apis.get_current_bet}`);
                if (result && (result.data || result.code === 0)) {
                    Logger.info("API Key验证成功");
                    return true;
                } else {
                    Logger.error(`API Key验证失败: 响应格式不正确`);
                    return false;
                }
            } catch (e) {
                Logger.warning("主服务器验证失败，尝试备用服务器...");
                try {
                    const result = await request(`${CONFIG.testHost}/${CONFIG.apis.get_current_bet}`);
                    if (result && (result.data || result.code === 0)) {
                        Logger.info("备用服务器API Key验证成功");
                        return true;
                    } else {
                        Logger.error(`备用服务器API Key验证失败: 响应格式不正确`);
                        return false;
                    }
                } catch (e2) {
                    Logger.error(`API Key验证失败: ${e2.message}`);
                    return false;
                }
            }
        }

        // 获取可投注项目
        async function loadBetItems() {
            updateLastActivity();
            try {
                Logger.info("正在获取可投注项目...", true);
                const data = await request(`${CONFIG.mainHost}/${CONFIG.apis.get_current_bet}`);
                CONFIG.state.availableBets = Array.isArray(data?.data) ? data.data : [];
                GlobalInfo.available_bets = CONFIG.state.availableBets;
                
                Logger.info(`找到可下注项目（${CONFIG.state.availableBets.length} 个）`);
                document.getElementById("availableBetsCount").textContent = `${CONFIG.state.availableBets.length} 个`;
                document.getElementById("availableBetsCount2").textContent = `${CONFIG.state.availableBets.length} 个项目`;
                
                // 更新AI准确率显示
                updateAiAccuracyDisplay();
                
                CONFIG.state.availableBets.forEach((betitem, idx) => {
                    Logger.info(`[ ${idx + 1} / ${CONFIG.state.availableBets.length} ] 项目id: ${betitem.id} 结束时间： ${betitem.endtime}`);
                    Logger.info(`${betitem.heading}, ${betitem.undertext || ''}`);
                    
                    if (betitem.optionsList && betitem.optionsList.length > 0) {
                        Logger.info(`可下注选项(共${betitem.optionsList.length}个)：`, true);
                        betitem.optionsList.forEach((opt, optIdx) => {
                            const aiPrediction = AIAnalytics.predictionCache[betitem.id];
                            const isAiPredicted = aiPrediction && opt.text.includes(aiPrediction.prediction);
                            Logger.info(`  [${optIdx + 1}] ${opt.text} (赔率: ${opt.odds}) ${isAiPredicted ? '[AI预测获胜]' : ''}`, true);
                        });
                    }
                    
                    // AI分析
                    if (CONFIG.state.betStrategy !== "follow" && CONFIG.state.aiPredictionEnabled) {
                        analyzeWithAI(betitem);
                    }
                    
                    // 跟随模式增强 - 预加载目标用户数据并启动智能监控
                    if (CONFIG.state.betStrategy === "follow" && isServiceRunning) {
                        preloadTargetUserData(betitem.id);
                        startSmartFollowingCheck(betitem.id);
                    }
                });
                
                await flushConfig();
                processPendingBets(true);
                renderBetTable();
                resetRefreshCycle();
                return true;
            } catch (e) {
                Logger.warning("主服务器获取失败，尝试备用服务器...");
                try {
                    const data = await request(`${CONFIG.testHost}/${CONFIG.apis.get_current_bet}`);
                    CONFIG.state.availableBets = Array.isArray(data?.data) ? data.data : [];
                    GlobalInfo.available_bets = CONFIG.state.availableBets;
                    
                    Logger.info(`从备用服务器找到可下注项目（${CONFIG.state.availableBets.length} 个）`);
                    document.getElementById("availableBetsCount").textContent = `${CONFIG.state.availableBets.length} 个`;
                    document.getElementById("availableBetsCount2").textContent = `${CONFIG.state.availableBets.length} 个项目`;
                    
                    // 更新AI准确率显示
                    updateAiAccuracyDisplay();
                    
                    await flushConfig();
                    processPendingBets(true);
                    renderBetTable();
                    resetRefreshCycle();
                    return true;
                } catch (e2) {
                    Logger.error(`获取投注项目失败: ${e2.message}`);
                    resetRefreshCycle();
                    return false;
                }
            }
        }

        // 刷新配置
        async function flushConfig() {
            const availableBets = GlobalInfo.available_bets;
            const newConfigs = {};
            
            GlobalInfo.bet_mask = {};
            
            availableBets.forEach(bet => {
                const id = bet.id;
                GlobalInfo.bet_mask[id] = [];
                
                const endTime = new Date(bet.endtime);
                const scheduledTime = new Date(endTime.getTime() - CONFIG.state.advanceSeconds * 1000);
                const scheduledTimeMulti = new Date(endTime.getTime() - CONFIG.state.advanceSeconds * 1000);
                
                newConfigs[id] = {
                    bet_id: id,
                    desc: `${bet.heading}, ${bet.undertext || ''}`,
                    scheduled_time: scheduledTime,
                    scheduled_time_multi: scheduledTimeMulti,
                    endtime: bet.endtime,
                    bias: CONFIG.state.advanceSeconds,
                    bonus: CONFIG.state.baseAmount, // 只使用基础金额
                    option_type: CONFIG.state.betStrategy
                };
            });
            
            GlobalInfo.configs = newConfigs;
            Logger.info(`配置已刷新，应用统一提前下注(${CONFIG.state.advanceSeconds}s)和容忍时间(${CONFIG.state.toleranceSeconds}s)`, true);
        }

        // 处理待投注项目
        function processPendingBets(refresh = false) {
            const now = new Date();
            const processingItems = refresh ? pendingBets.filter(bet => bet.status === "处理中") : [];
            let newPendingBets = [...processingItems];
            
            const candidateBets = [];
            Object.values(GlobalInfo.configs).forEach(cfg => {
                if (processingItems.some(bet => bet.id === cfg.bet_id)) {
                    return;
                }
                
                try {
                    const betItem = CONFIG.state.availableBets.find(item => item.id === cfg.bet_id);
                    if (!betItem) return;
                    
                    // 跟随模式不加入定时投注队列
                    if (CONFIG.state.betStrategy === "follow") {
                        return;
                    }
                    
                    const betTime = cfg.scheduled_time;
                    const toleranceTime = new Date(new Date(cfg.endtime).getTime() + CONFIG.state.toleranceSeconds * 1000);
                    
                    if (betTime > now && betTime < toleranceTime) {
                        if (shouldPlaceBet(betItem)) {
                            // 获取AI预测结果
                            const aiPrediction = AIAnalytics.predictionCache[betItem.id];
                            const selectedOption = aiPrediction 
                                ? betItem.optionsList.find(opt => opt.text.includes(aiPrediction.prediction))
                                : getHighestOddsOption(betItem);
                            
                            const betAmount = CONFIG.state.baseAmount; // 直接使用基础金额
                            const odds = selectedOption ? parseFloat(selectedOption.odds) : 0;
                            const ratioValue = odds * betAmount;
                            const profit = calculateProfitValue(betAmount, odds); // 计算收益
                            
                            candidateBets.push({
                                ...betItem,
                                id: cfg.bet_id,
                                betTime,
                                betAmount,
                                profit, // 新增收益字段
                                strategy: CONFIG.state.betStrategy,
                                status: "等待中",
                                highestOdds: odds,
                                highestOddsTeam: selectedOption ? selectedOption.text : 'N/A',
                                ratioValue: ratioValue,
                                recordedOdds: odds,
                                aiPrediction: aiPrediction ? `${aiPrediction.prediction} (${(aiPrediction.confidence * 100).toFixed(1)}%)` : null
                            });
                        }
                    }
                } catch (e) {
                    Logger.error(`处理项目 #${cfg.bet_id} 失败: ${e.message}`, true);
                }
            });
            
            let selectedBets = [];
            const betsByTimeGroup = {};
            candidateBets.forEach(bet => {
                const timeGroup = new Date(bet.betTime).toLocaleString('zh-CN', { 
                    year: 'numeric', 
                    month: '2-digit', 
                    day: '2-digit', 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                
                if (!betsByTimeGroup[timeGroup]) {
                    betsByTimeGroup[timeGroup] = [];
                }
                betsByTimeGroup[timeGroup].push(bet);
            });
            
            switch (CONFIG.state.pendingFilter) {
                case "all":
                    Object.values(betsByTimeGroup).forEach(group => {
                        selectedBets.push(...group);
                        Logger.info(`时间组 ${new Date(group[0].betTime).toLocaleString()} 选择所有 ${group.length} 个项目`, true);
                    });
                    break;
                    
                case "highest_odds":
                    Object.values(betsByTimeGroup).forEach(group => {
                        if (group.length === 0) return;
                        const selected = group.reduce((max, bet) => bet.highestOdds > max.highestOdds ? bet : max, group[0]);
                        selectedBets.push(selected);
                        Logger.info(`时间组 ${new Date(group[0].betTime).toLocaleString()} 选择最高赔率项目 #${selected.id} (${selected.highestOdds})`, true);
                    });
                    break;
                    
                case "highest_amount":
                    Object.values(betsByTimeGroup).forEach(group => {
                        if (group.length === 0) return;
                        const selected = group.reduce((max, bet) => bet.betAmount > max.betAmount ? bet : max, group[0]);
                        selectedBets.push(selected);
                        Logger.info(`时间组 ${new Date(group[0].betTime).toLocaleString()} 选择最高金额项目 #${selected.id} (${selected.betAmount})`, true);
                    });
                    break;
                    
                case "ratio_based":
                    Object.values(betsByTimeGroup).forEach(group => {
                        if (group.length === 0) return;
                        const selected = group.reduce((max, bet) => bet.ratioValue > max.ratioValue ? bet : max, group[0]);
                        selectedBets.push(selected);
                        Logger.info(`时间组 ${new Date(group[0].betTime).toLocaleString()} 选择最佳比例项目 #${selected.id} (${selected.ratioValue.toFixed(2)})`, true);
                    });
                    break;
            }
            
            newPendingBets = [...newPendingBets, ...selectedBets];
            newPendingBets.sort((a, b) => a.betTime - b.betTime);
            pendingBets = newPendingBets;
            document.getElementById("pendingBetsCount").textContent = `${pendingBets.length} 个`;
            document.getElementById("pendingBetsCount2").textContent = `${pendingBets.length} 个项目`;
            renderPendingBetsTable();
        }

        // 预加载目标用户数据（跟随模式增强）
        async function preloadTargetUserData(gameId) {
            const userId = CONFIG.state.targetUserId;
            
            // 检查缓存（缓存有效期10分钟）
            if (GlobalInfo.targetUserCache[userId]) {
                const now = new Date().getTime();
                if (now - GlobalInfo.targetUserCache[userId].loadTime < 10 * 60 * 1000) {
                    Logger.info(`项目 #${gameId} - 目标用户 ${userId} 数据已缓存，跳过预加载`, true);
                    return;
                }
            }
            
            try {
                Logger.info(`项目 #${gameId} - 预加载目标用户 ${userId} 数据...`, true);
                const url = `${CONFIG.mainHost}/${CONFIG.apis.get_user_profile.replace('{userId}', userId)}`;
                const data = await request(url);
                
                if (data?.data) {
                    // 分析用户投注行为模式
                    const userData = data.data;
                    const betPattern = userData.avgBetTimeDiff < 10000 ? 'lastSecond' : 'normal'; // 平均投注时间差<10秒判定为最后一秒模式
                    
                    GlobalInfo.targetUserCache[userId] = {
                        lastBetTime: userData.lastBetTime ? new Date(userData.lastBetTime).getTime() : null,
                        betPattern: betPattern,
                        avgBetTimeDiff: userData.avgBetTimeDiff || 0,
                        averageBetAmount: userData.averageBetAmount || 0,
                        loadTime: new Date().getTime()
                    };
                    
                    // 初始化用户投注行为分析
                    if (!GlobalInfo.userBetBehavior[userId]) {
                        GlobalInfo.userBetBehavior[userId] = {
                            last5BetTimeDiff: userData.last5BetTimeDiff || [],
                            predictBetTime: null // 预测的投注时间
                        };
                    }
                    
                    Logger.info(`项目 #${gameId} - 目标用户 ${userId} 数据预加载完成 (模式: ${betPattern}, 平均投注时差: ${(GlobalInfo.targetUserCache[userId].avgBetTimeDiff/1000).toFixed(1)}s)`, true);
                }
            } catch (e) {
                Logger.warning(`项目 #${gameId} - 预加载目标用户数据失败: ${e.message}`, true);
                // 失败时使用默认配置 + 行为分析
                GlobalInfo.targetUserCache[userId] = {
                    lastBetTime: null,
                    betPattern: 'lastSecond', // 默认按最后一秒投注模式处理
                    avgBetTimeDiff: 5000, // 默认平均5秒投注时差
                    averageBetAmount: 0,
                    loadTime: new Date().getTime()
                };
                
                // 初始化默认行为分析
                if (!GlobalInfo.userBetBehavior[userId]) {
                    GlobalInfo.userBetBehavior[userId] = {
                        last5BetTimeDiff: [3000, 2500, 4000, 3500, 2000], // 默认最近5次投注时差（毫秒）
                        predictBetTime: null
                    };
                }
            }
        }

        // 预测目标用户投注时间（核心优化：提前5-10秒预测）
        function predictUserBetTime(gameId) {
            const userId = CONFIG.state.targetUserId;
            const betItem = CONFIG.state.availableBets.find(item => item.id === gameId);
            if (!betItem || !GlobalInfo.userBetBehavior[userId]) return null;
            
            const endTime = new Date(betItem.endtime).getTime();
            const behaviorData = GlobalInfo.userBetBehavior[userId];
            
            // 计算历史平均投注时差
            const validTimeDiff = behaviorData.last5BetTimeDiff.filter(diff => diff > 0);
            if (validTimeDiff.length === 0) return null;
            
            const avgTimeDiff = validTimeDiff.reduce((sum, diff) => sum + diff, 0) / validTimeDiff.length;
            const stdDev = Math.sqrt(validTimeDiff.map(diff => Math.pow(diff - avgTimeDiff, 2)).reduce((sum, val) => sum + val, 0) / validTimeDiff.length);
            
            // 预测投注时间 = 结束时间 - (平均时差 + 1个标准差) + 提前量（确保提前5-10秒检测到）
            const predictTimeDiff = avgTimeDiff + stdDev;
            const predictBetTime = endTime - predictTimeDiff + 7000; // 额外加7秒提前量，确保提前5-10秒进入监控
            const emergencyWindowStart = endTime - CONFIG.state.followEmergencyWindow * 1000;
            
            // 确保预测时间在合理范围内
            const predictTime = Math.max(endTime - CONFIG.state.followPreCheckWindow * 1000, Math.min(predictBetTime, emergencyWindowStart));
            
            GlobalInfo.userBetBehavior[userId].predictBetTime = predictTime;
            Logger.info(`项目 #${gameId} - 预测目标用户投注时间: ${new Date(predictTime).toLocaleTimeString()} (结束时间: ${new Date(endTime).toLocaleTimeString()}, 预测提前: ${((endTime - predictTime)/1000).toFixed(1)}s)`, true);
            
            return predictTime;
        }

        // 获取目标用户的投注记录（增强版，支持预判断 & 快速响应）
        async function getTargetUserBet(gameId, checkOnly = false) {
            try {
                const userId = CONFIG.state.targetUserId;
                const userCache = GlobalInfo.targetUserCache[userId] || {};
                
                // 检查是否已跟随
                if (GlobalInfo.followedBets[gameId]) {
                    if (checkOnly) return { status: 'followed' };
                    return null;
                }
                
                // 获取项目详情
                const betItem = CONFIG.state.availableBets.find(item => item.id === gameId);
                if (!betItem) {
                    if (checkOnly) return { status: 'invalid' };
                    return null;
                }
                
                // 快速状态检查（优先查缓存）
                if (checkOnly && GlobalInfo.followedBets[gameId]) {
                    return { status: 'followed' };
                }
                
                Logger.info(`项目 #${gameId} - 获取目标用户 ${userId} 的投注记录 (当前模式: ${userCache.betPattern || 'lastSecond'})`, true);
                const url = `${CONFIG.mainHost}/${CONFIG.apis.get_gamblers.replace('{gameId}', gameId)}`;
                const data = await request(url, 'get', {}, 0); // 快速请求，不重试
                
                if (data?.data && Array.isArray(data.data)) {
                    const targetBet = data.data.find(log => log.userid === userId);
                    
                    if (targetBet) {
                        Logger.info(`项目 #${gameId} - 找到目标用户投注记录: 选项 ${targetBet.optionid}, 金额 ${targetBet.bonus}, 时间 ${new Date(targetBet.bettime).toLocaleTimeString()}`, true);
                        
                        // 更新用户投注行为分析
                        const endTime = new Date(betItem.endtime).getTime();
                        const betTime = new Date(targetBet.bettime).getTime();
                        const timeDiff = endTime - betTime;
                        
                        if (GlobalInfo.userBetBehavior[userId]) {
                            // 保留最近5次投注时差
                            GlobalInfo.userBetBehavior[userId].last5BetTimeDiff.push(timeDiff);
                            if (GlobalInfo.userBetBehavior[userId].last5BetTimeDiff.length > 5) {
                                GlobalInfo.userBetBehavior[userId].last5BetTimeDiff.shift();
                            }
                            
                            // 更新用户投注模式
                            const avgTimeDiff = GlobalInfo.userBetBehavior[userId].last5BetTimeDiff.reduce((sum, diff) => sum + diff, 0) / GlobalInfo.userBetBehavior[userId].last5BetTimeDiff.length;
                            GlobalInfo.targetUserCache[userId].betPattern = avgTimeDiff < 10000 ? 'lastSecond' : 'normal';
                            GlobalInfo.targetUserCache[userId].avgBetTimeDiff = avgTimeDiff;
                        }
                        
                        if (checkOnly) return { status: 'found', data: targetBet };
                        return targetBet;
                    } else {
                        if (checkOnly) return { status: 'not_found' };
                        return null;
                    }
                }
                
                if (checkOnly) return { status: 'error' };
                return null;
            } catch (e) {
                Logger.warning(`项目 #${gameId} - 获取用户投注记录失败，尝试备用服务器快速查询`, true);
                try {
                    const url = `${CONFIG.testHost}/${CONFIG.apis.get_gamblers.replace('{gameId}', gameId)}`;
                    const data = await request(url, 'get', {}, 0); // 快速请求，不重试
                    
                    if (data?.data && Array.isArray(data.data)) {
                        const targetBet = data.data.find(log => log.userid === CONFIG.state.targetUserId);
                        if (checkOnly) return { status: targetBet ? 'found' : 'not_found' };
                        return targetBet;
                    }
                    
                    if (checkOnly) return { status: 'error' };
                    return null;
                } catch (e2) {
                    Logger.error(`项目 #${gameId} - 获取用户投注记录失败: ${e2.message}`, true);
                    if (checkOnly) return { status: 'error' };
                    return null;
                }
            }
        }

        // 智能跟随检查（优化版：基于行为预测的动态监控）
        function startSmartFollowingCheck(gameId) {
            // 清除已有定时器
            if (followCheckTimers[gameId]) {
                clearInterval(followCheckTimers[gameId]);
            }
            
            // 检查是否已跟随
            if (GlobalInfo.followedBets[gameId]) {
                return;
            }
            
            const userId = CONFIG.state.targetUserId;
            const userCache = GlobalInfo.targetUserCache[userId] || { betPattern: 'lastSecond' };
            const betItem = CONFIG.state.availableBets.find(item => item.id === gameId);
            if (!betItem) return;
            
            const endTime = new Date(betItem.endtime).getTime();
            const now = new Date().getTime();
            
            // 预测用户投注时间
            const predictBetTime = predictUserBetTime(gameId);
            const preCheckWindowStart = endTime - CONFIG.state.followPreCheckWindow * 1000;
            const emergencyWindowStart = endTime - CONFIG.state.followEmergencyWindow * 1000;
            
            // 计算初始检查间隔
            let checkInterval = userCache.betPattern === 'lastSecond' ? 100 : 500;
            let currentMode = 'normal';
            
            // 根据预测时间调整初始模式
            if (predictBetTime && now >= predictBetTime - 2000) {
                checkInterval = 50; // 预测投注时间前2秒进入紧急检查
                currentMode = 'predict';
                Logger.info(`项目 #${gameId} - 进入预测投注窗口期，调整检查间隔为 50ms`, true);
            } else if (now >= preCheckWindowStart) {
                checkInterval = userCache.betPattern === 'lastSecond' ? 100 : 300;
                currentMode = 'preCheck';
                Logger.info(`项目 #${gameId} - 进入提前检查窗口期，调整检查间隔为 ${checkInterval}ms`, true);
            }
            
            Logger.info(`项目 #${gameId} - 启动智能监控 (模式: ${currentMode}, 基础间隔: ${checkInterval}ms)`, true);
            
            // 先执行一次快速检查
            checkTargetBetStatus(gameId);
            
            // 设置主检查定时器
            followCheckTimers[gameId] = setInterval(async () => {
                if (!isServiceRunning) {
                    clearInterval(followCheckTimers[gameId]);
                    delete followCheckTimers[gameId];
                    return;
                }
                
                const currentTime = new Date().getTime();
                
                // 动态调整检查间隔
                if (currentTime >= emergencyWindowStart && checkInterval > 50) {
                    // 进入最后5秒紧急窗口，强制50ms间隔
                    clearInterval(followCheckTimers[gameId]);
                    checkInterval = 50;
                    followCheckTimers[gameId] = setInterval(async () => {
                        await checkTargetBetStatus(gameId);
                    }, checkInterval);
                    Logger.info(`项目 #${gameId} - 进入最后${CONFIG.state.followEmergencyWindow}秒紧急监控，调整间隔为 50ms`, true);
                } else if (predictBetTime && currentTime >= predictBetTime - 1000 && checkInterval > 50) {
                    // 预测投注时间前1秒，调整为50ms间隔
                    clearInterval(followCheckTimers[gameId]);
                    checkInterval = 50;
                    followCheckTimers[gameId] = setInterval(async () => {
                        await checkTargetBetStatus(gameId);
                    }, checkInterval);
                    Logger.info(`项目 #${gameId} - 接近预测投注时间，调整间隔为 50ms`, true);
                }
                
                // 执行状态检查
                await checkTargetBetStatus(gameId);
            }, checkInterval);
        }

        // 检查目标用户投注状态（核心优化点）
        async function checkTargetBetStatus(gameId) {
            // 检查项目是否仍然有效
            const betItem = CONFIG.state.availableBets.find(item => item.id === gameId);
            if (!betItem) {
                clearInterval(followCheckTimers[gameId]);
                delete followCheckTimers[gameId];
                Logger.info(`项目 #${gameId} 已失效，停止监控`, true);
                return;
            }
            
            // 检查是否已过投注时间
            const endTime = new Date(betItem.endtime).getTime();
            const now = new Date().getTime();
            const toleranceTime = endTime + CONFIG.state.toleranceSeconds * 1000;
            
            if (now > toleranceTime) {
                clearInterval(followCheckTimers[gameId]);
                delete followCheckTimers[gameId];
                Logger.info(`项目 #${gameId} 已超过容忍时间，停止监控`, true);
                return;
            }
            
            // 快速状态检查（仅返回状态，不获取完整数据）
            const statusCheck = await getTargetUserBet(gameId, true);
            
            switch (statusCheck.status) {
                case 'followed':
                    clearInterval(followCheckTimers[gameId]);
                    delete followCheckTimers[gameId];
                    Logger.info(`项目 #${gameId} - 已跟随投注，停止监控`, true);
                    break;
                    
                case 'invalid':
                    clearInterval(followCheckTimers[gameId]);
                    delete followCheckTimers[gameId];
                    Logger.info(`项目 #${gameId} - 项目无效，停止监控`, true);
                    break;
                    
                case 'found':
                    // 发现目标用户已投注，立即执行跟随
                    await executeFollowBet(gameId, statusCheck.data);
                    break;
                    
                case 'not_found':
                    // 未找到投注记录，继续监控
                    break;
                    
                case 'error':
                    // 请求错误，500ms后重试一次
                    setTimeout(() => checkTargetBetStatus(gameId), 500);
                    break;
            }
        }

        // 执行跟随投注（优化版）
        async function executeFollowBet(gameId, targetBet) {
            // 清除监控定时器
            if (followCheckTimers[gameId]) {
                clearInterval(followCheckTimers[gameId]);
                delete followCheckTimers[gameId];
            }
            
            // 检查项目是否有效
            const betItem = CONFIG.state.availableBets.find(item => item.id === gameId);
            if (!betItem) {
                Logger.error(`项目 #${gameId} 已失效，跟随投注取消`, true);
                return false;
            }
            
            // 找到对应的选项
            const option = betItem.optionsList.find(opt => opt.id === targetBet.optionid);
            if (!option) {
                Logger.error(`跟随投注失败: 选项 ${targetBet.optionid} 不存在`);
                return false;
            }
            
            Logger.info(`项目 #${gameId} - 检测到目标用户投注，立即执行跟随 (选项: ${option.text}, 赔率: ${option.odds})`, true);
            
            // 计算跟随金额（使用基础金额）
            const followAmount = CONFIG.state.baseAmount;
            
            // 创建跟随投注对象
            const followBet = {
                ...betItem,
                id: gameId,
                betTime: new Date(),
                betAmount: followAmount,
                profit: calculateProfitValue(followAmount, parseFloat(option.odds)), // 计算收益
                strategy: "follow",
                status: "处理中",
                highestOddsTeam: option.text,
                highestOdds: parseFloat(option.odds || 0),
                ratioValue: 0,
                recordedOdds: 0,
                follower: true // 标记为跟随投注
            };
            
            // 添加到待投注列表
            pendingBets.unshift(followBet);
            renderPendingBetsTable();
            
            // 执行投注请求
            const success = await placeFollowBet(followBet, targetBet.optionid);
            
            // 更新状态
            const index = pendingBets.findIndex(b => b.id === gameId && b.status === "处理中");
            if (index !== -1) {
                pendingBets[index].status = success ? "已完成" : "失败";
                renderPendingBetsTable();
            }
            
            // 记录已跟随状态
            GlobalInfo.followedBets[gameId] = {
                optionId: targetBet.optionid,
                amount: followAmount,
                status: success ? 'success' : 'failed',
                betTime: new Date().getTime()
            };
            
            // 投注成功后更新AI预测准确率（如果有AI预测）
            const aiPrediction = AIAnalytics.predictionCache[gameId];
            if (aiPrediction && success) {
                const isCorrect = option.text.includes(aiPrediction.prediction);
                AIAnalytics.accuracyStats.total++;
                if (isCorrect) {
                    AIAnalytics.accuracyStats.correct++;
                }
                updateAiAccuracyDisplay();
                Logger.info(`项目 #${gameId} - AI预测验证: ${isCorrect ? '正确' : '错误'} (当前准确率: ${calculateAiAccuracy()}%)`, true);
            }
            
            // 投注成功后自动刷新
            if (success) {
                Logger.success(`项目 #${gameId} - 跟随投注成功，3秒后自动刷新数据`);
                setTimeout(() => loadBetItems(), 3000);
            }
            
            return success;
        }

        // 计算跟随金额（简化版，只使用基础金额）
        function calculateFollowAmount() {
            return CONFIG.state.baseAmount;
        }

        // 执行跟随投注（修复状态判断 & 日志显示）
        async function placeFollowBet(followBet, optionId) {
            updateLastActivity();
            try {
                Logger.info(`开始跟随投注项目 #${followBet.id}，选项: ${followBet.highestOddsTeam}, 金额: ${followBet.betAmount}`);
                
                // 执行投注请求
                const url = `${CONFIG.mainHost}/${CONFIG.apis.betgameOdds
                    .replace('{optId}', optionId)
                    .replace('{bonus}', followBet.betAmount)}`;
                
                const result = await request(url);
                
                // 修复1: 完善的成功判断逻辑
                const isSuccess = checkBetSuccess(result);
                
                if (!isSuccess) {
                    const errorMsg = result.msg || '未知错误';
                    Logger.error(`跟随投注失败: ${errorMsg}`);
                    return false;
                }
                
                Logger.success(`跟随投注成功: 项目 #${followBet.id}，选项 ${followBet.highestOddsTeam}，金额 ${followBet.betAmount}`);
                
                // 记录投注记录
                if (!GlobalInfo.bet_mask[followBet.id]) {
                    GlobalInfo.bet_mask[followBet.id] = [];
                }
                GlobalInfo.bet_mask[followBet.id].push(optionId);
                
                return true;
            } catch (e) {
                Logger.warning("主服务器跟随投注失败，尝试备用服务器...");
                try {
                    const url = `${CONFIG.testHost}/${CONFIG.apis.betgameOdds
                        .replace('{optId}', optionId)
                        .replace('{bonus}', followBet.betAmount)}`;
                    
                    const result = await request(url);
                    
                    // 修复1: 完善的成功判断逻辑
                    const isSuccess = checkBetSuccess(result);
                    
                    if (!isSuccess) {
                        const errorMsg = result.msg || '未知错误';
                        Logger.error(`备用服务器 - 跟随投注失败: ${errorMsg}`);
                        return false;
                    }
                    
                    Logger.success(`备用服务器 - 跟随投注成功: 项目 #${followBet.id}，选项 ${followBet.highestOddsTeam}，金额 ${followBet.betAmount}`);
                    
                    if (!GlobalInfo.bet_mask[followBet.id]) {
                        GlobalInfo.bet_mask[followBet.id] = [];
                    }
                    GlobalInfo.bet_mask[followBet.id].push(optionId);
                    
                    return true;
                } catch (e2) {                    Logger.error(`跟随投注请求失败: ${e2.message}`);
                    return false;
                }
            }
        }

        // 检查投注是否成功（修复：完善判断逻辑）
        function checkBetSuccess(result) {
            // 综合判断多种可能的成功响应格式，解决"未知错误"显示问题
            return result && (
                result.code === 0 || 
                result.success === true || 
                (result.data && result.data.status === 'success') ||
                (result.msg && (result.msg.includes('成功') || result.msg.includes('success')))
            );
        }

        // 获取最高赔率选项
        function getHighestOddsOption(betItem) {
            if (!betItem.optionsList || betItem.optionsList.length === 0) return null;
            
            let highestOdds = -Infinity;
            let highestOption = null;
            
            betItem.optionsList.forEach(option => {
                const odds = parseFloat(option.odds);
                if (odds > highestOdds) {
                    highestOdds = odds;
                    highestOption = option;
                }
            });
            
            return highestOption;
        }

        // 获取押大选项
        async function getLargerOptions(gameId) {
            try {
                const url = `${CONFIG.mainHost}/${CONFIG.apis.get_details.replace('{gameId}', gameId)}`;
                const data = await request(url);
                
                if (!data?.data || !data.data.optionsList) return [];
                
                const options = data.data.optionsList;
                if (options.length > 3) return [];
                
                let minOddsIndex = 0;
                options.forEach((opt, idx) => {
                    if (parseFloat(opt.odds) <= parseFloat(options[minOddsIndex].odds)) {
                        minOddsIndex = idx;
                    }
                });
                
                return options.filter((_, idx) => idx !== minOddsIndex).map(opt => opt.id);
            } catch (e) {
                Logger.error(`获取押大选项失败: ${e.message}`, true);
                return [];
            }
        }

        // 获取押小选项
        async function getSmallerOptions(gameId) {
            try {
                const url = `${CONFIG.mainHost}/${CONFIG.apis.get_details.replace('{gameId}', gameId)}`;
                const data = await request(url);
                
                if (!data?.data || !data.data.optionsList) return [];
                
                const options = data.data.optionsList;
                if (options.length > 3) return [];
                
                let maxOddsIndex = 0;
                options.forEach((opt, idx) => {
                    if (parseFloat(opt.odds) >= parseFloat(options[maxOddsIndex].odds)) {
                        maxOddsIndex = idx;
                    }
                });
                
                return options.filter((_, idx) => idx !== maxOddsIndex).map(opt => opt.id);
            } catch (e) {
                Logger.error(`获取押小选项失败: ${e.message}`, true);
                return [];
            }
        }

        // AI分析模块（增加准确率统计 & 获胜标识）
        async function analyzeWithAI(betItem) {
            try {
                Logger.info(`开始AI分析项目 #${betItem.id}...`, true);
                
                // 提取队伍信息
                const teams = betItem.optionsList.map(opt => opt.text.trim());
                
                // 获取每支队伍的历史数据
                const teamDataPromises = teams.map(team => fetchTeamHistory(team));
                const teamDataArray = await Promise.all(teamDataPromises);
                
                // 分析数据并预测结果
                const prediction = predictWinner(teamDataArray, teams, betItem);
                
                // 缓存预测结果
                AIAnalytics.predictionCache[betItem.id] = prediction;
                
                Logger.info(`AI分析完成项目 #${betItem.id}: 预测 ${prediction.prediction} (可信度: ${(prediction.confidence * 100).toFixed(1)}%)`, true);
                return prediction;
            } catch (e) {
                Logger.error(`AI分析失败: ${e.message}`, true);
                return null;
            }
        }

        // 获取队伍历史数据
        async function fetchTeamHistory(teamName) {
            try {
                const teamId = teamName.hashCode(); // 使用哈希作为临时teamId
                
                // 检查缓存（有效期30分钟）
                if (AIAnalytics.historicalData[teamId]) {
                    const now = new Date().getTime();
                    if (now - AIAnalytics.historicalData[teamId].timestamp < 30 * 60 * 1000) {
                        Logger.info(`使用缓存的队伍数据: ${teamName}`, true);
                        return AIAnalytics.historicalData[teamId];
                    }
                }
                
                Logger.info(`获取队伍历史数据: ${teamName}`, true);
                const url = `${CONFIG.mainHost}/${CONFIG.apis.get_team_history.replace('{teamId}', teamId)}`;
                const data = await request(url);
                
                // 处理历史数据
                const historyData = {
                    teamId,
                    teamName,
                    wins: 0,
                    losses: 0,
                    total: 0,
                    recentScores: [],
                    timestamp: new Date().getTime()
                };
                
                if (data?.data && Array.isArray(data.data.matches)) {
                    data.data.matches.forEach(match => {
                        historyData.total++;
                        if (match.result === 'win') {
                            historyData.wins++;
                        } else {
                            historyData.losses++;
                        }
                        
                        if (historyData.recentScores.length < 5) {
                            historyData.recentScores.push(match.score || 0);
                        }
                    });
                } else {
                    // 模拟数据（API不可用时）
                    historyData.wins = Math.floor(Math.random() * 10) + 5;
                    historyData.losses = Math.floor(Math.random() * 5);
                    historyData.total = historyData.wins + historyData.losses;
                    historyData.recentScores = Array.from({length: 5}, () => Math.floor(Math.random() * 100));
                    Logger.warning(`使用模拟数据: ${teamName}`, true);
                }
                
                // 保存到缓存
                AIAnalytics.historicalData[teamId] = historyData;
                return historyData;
            } catch (e) {
                Logger.warning(`获取队伍历史数据失败，使用模拟数据: ${e.message}`, true);
                // 生成模拟数据
                const teamId = teamName.hashCode();
                const historyData = {
                    teamId,
                    teamName,
                    wins: Math.floor(Math.random() * 10) + 5,
                    losses: Math.floor(Math.random() * 5),
                    total: 0,
                    recentScores: Array.from({length: 5}, () => Math.floor(Math.random() * 100)),
                    timestamp: new Date().getTime()
                };
                historyData.total = historyData.wins + historyData.losses;
                AIAnalytics.historicalData[teamId] = historyData;
                return historyData;
            }
        }

        // 预测获胜队伍
        function predictWinner(teamDataArray, teamNames, betItem) {
            // 计算每支队伍的胜率
            const winRates = teamDataArray.map(data => {
                return data.total > 0 ? data.wins / data.total : 0.5; // 无数据时默认50%
            });
            
            // 计算最近表现趋势（最近5场平均得分变化）
            const recentTrends = teamDataArray.map(data => {
                if (data.recentScores.length < 2) return 0;
                let trend = 0;
                for (let i = 1; i < data.recentScores.length; i++) {
                    trend += data.recentScores[i] - data.recentScores[i-1];
                }
                return trend / (data.recentScores.length - 1);
            });
            
            // 计算赔率因素（赔率低的队伍通常被看好）
            const oddsFactors = teamNames.map((name, idx) => {
                const option = betItem.optionsList.find(opt => opt.text.includes(name));
                if (!option) return 0;
                const odds = parseFloat(option.odds);
                return 1 / odds; // 赔率越低，此值越高
            });
            
            // 综合评分（权重：胜率60%，趋势20%，赔率20%）
            const scores = teamDataArray.map((_, idx) => {
                return winRates[idx] * 0.6 + 
                       (recentTrends[idx] / 100 + 0.5) * 0.2 + // 标准化趋势值
                       oddsFactors[idx] * 0.2;
            });
            
            // 找出最高分的队伍
            let maxScore = -Infinity;
            let maxIndex = 0;
            
            scores.forEach((score, idx) => {
                if (score > maxScore) {
                    maxScore = score;
                    maxIndex = idx;
                }
            });
            
            // 计算可信度（最高分与次高分的差值）
            let confidence = 0.5;
            if (scores.length > 1) {
                const sortedScores = [...scores].sort((a, b) => b - a);
                confidence = 0.5 + (sortedScores[0] - sortedScores[1]) * 0.5;
                confidence = Math.min(0.95, Math.max(0.5, confidence)); // 限制在0.5-0.95之间
            }
            
            return {
                prediction: teamNames[maxIndex],
                confidence: confidence,
                scores: scores.map((s, i) => ({ team: teamNames[i], score: s }))
            };
        }

        // 计算AI预测准确率
        function calculateAiAccuracy() {
            if (AIAnalytics.accuracyStats.total === 0) return 0;
            return (AIAnalytics.accuracyStats.correct / AIAnalytics.accuracyStats.total) * 100;
        }

        // 更新AI准确率显示
        function updateAiAccuracyDisplay() {
            const accuracy = calculateAiAccuracy();
            document.getElementById("aiAccuracy").textContent = accuracy > 0 
                ? `${accuracy.toFixed(1)}%` 
                : "--%";
        }

        // 计算收益值（新增：用于金额设置中的实时计算）
        function calculateProfitValue(amount, odds) {
            if (!odds || odds <= 1) return 0;
            return Math.round(amount * (odds - 1));
        }

        // 计算收益显示（新增：实时计算并显示预计收益）
        function calculateProfit() {
            const baseAmount = parseFloat(document.getElementById("baseAmountInput").value) || 0;
            // 使用示例赔率1.95计算预期收益（可根据实际需求调整为实时赔率）
            const exampleOdds = 1.95;
            const profit = calculateProfitValue(baseAmount, exampleOdds);
            const profitRate = ((exampleOdds - 1) * 100).toFixed(1);
            
            document.getElementById("baseProfitDisplay").textContent = profit.toLocaleString();
            document.getElementById("profitRateDisplay").textContent = `${profitRate}%`;
        }

        // 判断是否应该下注
        function shouldPlaceBet(betItem) {
            // 检查是否已下注
            if (GlobalInfo.bet_mask[betItem.id] && GlobalInfo.bet_mask[betItem.id].length > 0) {
                return false;
            }
            
            // 检查是否有可用选项
            if (!betItem.optionsList || betItem.optionsList.length === 0) {
                return false;
            }
            
            // 检查赔率是否有效
            const highestOdds = getHighestOddsOption(betItem);
            if (!highestOdds || parseFloat(highestOdds.odds) <= 1) {
                return false;
            }
            
            return true;
        }

        // 渲染投注表格（优化：AI预测获胜队伍显示"AI"标识）
        function renderBetTable() {
            const table = document.getElementById("betItemsTable");
            if (!table) return;
            
            if (CONFIG.state.availableBets.length === 0) {
                table.innerHTML = `
                    <tr>
                        <td colspan="7" class="border border-gray-200 p-8 text-center text-gray-500">
                            <div class="flex flex-col items-center">
                                <i class="fa fa-inbox text-3xl mb-2 text-gray-300"></i>
                                <span>暂无可用投注项目</span>
                            </div>
                        </td>
                    </tr>
                `;
                return;
            }
            
            let html = `
                <thead>
                    <tr class="bg-gray-50">
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ID</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">项目名称</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">选项 (赔率)</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">最高赔率</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">AI预测</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">结束时间</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">状态</th>
                    </tr>
                </thead>
                <tbody class="bg-white divide-y divide-gray-200">
            `;
            
            CONFIG.state.availableBets.forEach(betItem => {
                const config = GlobalInfo.configs[betItem.id];
                const betTime = config ? config.scheduled_time : null;
                const endTime = new Date(betItem.endtime);
                const isExpired = new Date() > endTime;
                const isBetPlaced = GlobalInfo.bet_mask[betItem.id] && GlobalInfo.bet_mask[betItem.id].length > 0;
                const highestOddsOption = getHighestOddsOption(betItem);
                const aiPrediction = AIAnalytics.predictionCache[betItem.id];
                
                // 状态判断
                let statusText = "可投注";
                let statusClass = "text-gray-600";
                
                if (isExpired) {
                    statusText = "已结束";
                    statusClass = "text-gray-400";
                } else if (isBetPlaced) {
                    statusText = "已投注";
                    statusClass = "text-success";
                } else if (CONFIG.state.betStrategy === "follow") {
                    if (GlobalInfo.followedBets[betItem.id]) {
                        statusText = "已跟随";
                        statusClass = "text-purple";
                    } else if (followCheckTimers[betItem.id]) {
                        statusText = "监控中";
                        statusClass = "text-primary";
                    }
                }
                
                html += `
                    <tr class="table-hover-row ${isExpired ? 'opacity-50' : ''} ${isBetPlaced ? 'bg-gray-50' : ''}">
                        <td class="px-4 py-3 whitespace-nowrap text-sm">${betItem.id}</td>
                        <td class="px-4 py-3 text-sm">
                            <div class="font-medium">${betItem.heading}</div>
                            <div class="text-gray-500 text-xs">${betItem.undertext || ''}</div>
                        </td>
                        <td class="px-4 py-3 text-sm">
                            <ul class="space-y-1">
                `;
                
                // 选项列表（AI预测获胜项添加"AI"标识）
                betItem.optionsList.forEach(option => {
                    const isHighest = highestOddsOption && option.id === highestOddsOption.id;
                    const isAiPredicted = aiPrediction && option.text.includes(aiPrediction.prediction);
                    
                    html += `
                        <li class="${isHighest ? 'odds-highlight pl-3' : ''} ${isAiPredicted ? 'ai-highlight' : ''}">
                            ${option.text} <span class="text-primary font-medium">${option.odds}</span>
                        </li>
                    `;
                });
                
                html += `
                            </ul>
                        </td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm font-medium text-primary">
                            ${highestOddsOption ? highestOddsOption.odds : '-'}
                        </td>
                        <td class="px-4 py-3 text-sm">
                            ${aiPrediction ? `${aiPrediction.prediction} (${(aiPrediction.confidence * 100).toFixed(1)}%)` : '-'}
                        </td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm">
                            ${endTime.toLocaleString('zh-CN')}
                        </td>
                        <td class="px-4 py-3 whitespace-nowrap">
                            <span class="status-badge ${statusClass}">${statusText}</span>
                        </td>
                    </tr>
                `;
            });
            
            html += `</tbody>`;
            table.innerHTML = html;
        }

        // 渲染待投注表格（优化：显示预计收益）
        function renderPendingBetsTable() {
            const table = document.getElementById("pendingBetsTable");
            if (!table) return;
            
            if (pendingBets.length === 0) {
                table.innerHTML = `
                    <tr>
                        <td colspan="8" class="border border-gray-200 p-8 text-center text-gray-500">
                            <div class="flex flex-col items-center">
                                <i class="fa fa-hourglass-o text-3xl mb-2 text-gray-300"></i>
                                <span>暂无待投注项目</span>
                            </div>
                        </td>
                    </tr>
                `;
                return;
            }
            
            let html = `
                <thead>
                    <tr class="bg-gray-50">
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ID</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">项目名称</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">投注选项</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">赔率</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">投注金额</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">预计收益</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">投注时间</th>
                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">状态</th>
                    </tr>
                </thead>
                <tbody class="bg-white divide-y divide-gray-200">
            `;
            
            pendingBets.forEach(bet => {
                const now = new Date();
                const timeDiff = bet.betTime - now;
                const minutes = Math.floor(Math.abs(timeDiff) / 60000);
                const seconds = Math.floor((Math.abs(timeDiff) % 60000) / 1000);
                const timeDiffText = timeDiff > 0 
                    ? `还有 ${minutes}分${seconds}秒` 
                    : `已超时 ${minutes}分${seconds}秒`;
                
                let statusClass = '';
                switch (bet.status) {
                    case '等待中':
                        statusClass = 'bg-yellow-100 text-yellow-800';
                        break;
                    case '处理中':
                        statusClass = 'bg-blue-100 text-blue-800';
                        break;
                    case '已完成':
                        statusClass = 'bg-green-100 text-green-800';
                        break;
                    case '失败':
                        statusClass = 'bg-red-100 text-red-800';
                        break;
                }
                
                html += `
                    <tr class="table-hover-row ${bet.follower ? 'bg-purple-50' : ''}">
                        <td class="px-4 py-3 whitespace-nowrap text-sm">${bet.id}</td>
                        <td class="px-4 py-3 text-sm">
                            <div class="font-medium ${bet.follower ? 'follower-indicator' : ''}">${bet.heading}</div>
                            <div class="text-gray-500 text-xs">${bet.undertext || ''}</div>
                        </td>
                        <td class="px-4 py-3 text-sm">
                            ${bet.highestOddsTeam}
                            ${bet.aiPrediction ? `<div class="text-xs text-ai">${bet.aiPrediction}</div>` : ''}
                        </td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm font-medium text-primary">
                            ${bet.highestOdds.toFixed(2)}
                        </td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm">
                            ${bet.betAmount.toLocaleString()}
                        </td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm text-success">
                            ${bet.profit.toLocaleString()}
                        </td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm">
                            <div>${bet.betTime.toLocaleString('zh-CN')}</div>
                            <div class="text-xs ${timeDiff <= 0 ? 'text-warning' : 'text-gray-500'}">${timeDiffText}</div>
                        </td>
                        <td class="px-4 py-3 whitespace-nowrap">
                            <span class="status-badge ${statusClass}">${bet.status}</span>
                        </td>
                    </tr>
                `;
            });
            
            html += `</tbody>`;
            table.innerHTML = html;
        }

        // 手动投注
        async function manualPlaceBet(gameId) {
            const betItem = CONFIG.state.availableBets.find(item => item.id === gameId);
            if (!betItem) {
                alert("未找到该投注项目");
                return;
            }
            
            // 检查是否已投注
            if (GlobalInfo.bet_mask[gameId] && GlobalInfo.bet_mask[gameId].length > 0) {
                alert("该项目已投注");
                return;
            }
            
            // 获取投注选项
            let selectedOptionId = null;
            let selectedOption = null;
            
            switch (CONFIG.state.betStrategy) {
                case "higher_odds":
                    selectedOption = getHighestOddsOption(betItem);
                    if (selectedOption) selectedOptionId = selectedOption.id;
                    break;
                case "follow":
                    alert("跟随模式下请等待系统自动跟随");
                    return;
                case "larger":
                    const largerOptions = await getLargerOptions(gameId);
                    if (largerOptions.length > 0) selectedOptionId = largerOptions[0];
                    break;
                case "smaller":
                    const smallerOptions = await getSmallerOptions(gameId);
                    if (smallerOptions.length > 0) selectedOptionId = smallerOptions[0];
                    break;
            }
            
            if (!selectedOptionId) {
                // 手动选择选项
                const optionsHtml = betItem.optionsList.map(opt => 
                    `<option value="${opt.id}">${opt.text} (${opt.odds})</option>`
                ).join("");
                
                const selected = prompt(`请选择投注选项:\n${betItem.optionsList.map(opt => `${opt.id}: ${opt.text} (${opt.odds})`).join("\n")}`);
                if (!selected) return;
                selectedOptionId = selected;
                selectedOption = betItem.optionsList.find(opt => opt.id === selectedOptionId);
            }
            
            if (!selectedOptionId || !selectedOption) {
                alert("无效的投注选项");
                return;
            }
            
            // 创建投注对象
            const manualBet = {
                ...betItem,
                id: gameId,
                betTime: new Date(),
                betAmount: CONFIG.state.baseAmount,
                profit: calculateProfitValue(CONFIG.state.baseAmount, parseFloat(selectedOption.odds)), // 计算收益
                strategy: CONFIG.state.betStrategy,
                status: "处理中",
                highestOddsTeam: selectedOption.text,
                highestOdds: parseFloat(selectedOption.odds || 0),
                ratioValue: 0,
                recordedOdds: 0
            };
            
            // 添加到待投注列表
            pendingBets.unshift(manualBet);
            renderPendingBetsTable();
            
            // 执行投注
            try {
                Logger.info(`手动投注项目 #${gameId}，选项: ${selectedOption.text}, 金额: ${CONFIG.state.baseAmount}`);
                
                const url = `${CONFIG.mainHost}/${CONFIG.apis.betgameOdds
                    .replace('{optId}', selectedOptionId)
                    .replace('{bonus}', CONFIG.state.baseAmount)}`;
                
                const result = await request(url);
                
                // 修复：完善的成功判断
                const isSuccess = checkBetSuccess(result);
                
                if (!isSuccess) {
                    const errorMsg = result.msg || '未知错误';
                    Logger.error(`手动投注失败: ${errorMsg}`);
                    alert(`投注失败: ${errorMsg}`);
                    
                    // 更新状态
                    const index = pendingBets.findIndex(b => b.id === gameId && b.status === "处理中");
                    if (index !== -1) {
                        pendingBets[index].status = "失败";
                        renderPendingBetsTable();
                    }
                    
                    return;
                }
                
                Logger.success(`手动投注成功: 项目 #${gameId}，选项 ${selectedOption.text}，金额 ${CONFIG.state.baseAmount}`);
                alert("投注成功");
                
                // 记录投注记录
                if (!GlobalInfo.bet_mask[gameId]) {
                    GlobalInfo.bet_mask[gameId] = [];
                }
                GlobalInfo.bet_mask[gameId].push(selectedOptionId);
                
                // 更新状态
                const index = pendingBets.findIndex(b => b.id === gameId && b.status === "处理中");
                if (index !== -1) {
                    pendingBets[index].status = "已完成";
                    renderPendingBetsTable();
                }
                
                // 更新AI预测准确率
                const aiPrediction = AIAnalytics.predictionCache[gameId];
                if (aiPrediction) {
                    const isCorrect = selectedOption.text.includes(aiPrediction.prediction);
                    AIAnalytics.accuracyStats.total++;
                    if (isCorrect) {
                        AIAnalytics.accuracyStats.correct++;
                    }
                    updateAiAccuracyDisplay();
                    Logger.info(`项目 #${gameId} - AI预测验证: ${isCorrect ? '正确' : '错误'} (当前准确率: ${calculateAiAccuracy()}%)`, true);
                }
                
                // 刷新数据
                setTimeout(() => loadBetItems(), 1000);
                
            } catch (e) {
                Logger.warning("主服务器手动投注失败，尝试备用服务器...");
                try {
                    const url = `${CONFIG.testHost}/${CONFIG.apis.betgameOdds
                        .replace('{optId}', selectedOptionId)
                        .replace('{bonus}', CONFIG.state.baseAmount)}`;
                    
                    const result = await request(url);
                    
                    // 修复：完善的成功判断
                    const isSuccess = checkBetSuccess(result);
                    
                    if (!isSuccess) {
                        const errorMsg = result.msg || '未知错误';
                        Logger.error(`备用服务器 - 手动投注失败: ${errorMsg}`);
                        alert(`投注失败: ${errorMsg}`);
                        
                        // 更新状态
                        const index = pendingBets.findIndex(b => b.id === gameId && b.status === "处理中");
                        if (index !== -1) {
                            pendingBets[index].status = "失败";
                            renderPendingBetsTable();
                        }
                        
                        return;
                    }
                    
                    Logger.success(`备用服务器 - 手动投注成功: 项目 #${gameId}，选项 ${selectedOption.text}，金额 ${CONFIG.state.baseAmount}`);
                    alert("投注成功");
                    
                    // 记录投注记录
                    if (!GlobalInfo.bet_mask[gameId]) {
                        GlobalInfo.bet_mask[gameId] = [];
                    }
                    GlobalInfo.bet_mask[gameId].push(selectedOptionId);
                    
                    // 更新状态
                    const index = pendingBets.findIndex(b => b.id === gameId && b.status === "处理中");
                    if (index !== -1) {
                        pendingBets[index].status = "已完成";
                        renderPendingBetsTable();
                    }
                    
                    // 刷新数据
                    setTimeout(() => loadBetItems(), 1000);
                    
                } catch (e2) {
                    Logger.error(`手动投注请求失败: ${e2.message}`);
                    alert(`投注失败: ${e2.message}`);
                    
                    // 更新状态
                    const index = pendingBets.findIndex(b => b.id === gameId && b.status === "处理中");
                    if (index !== -1) {
                        pendingBets[index].status = "失败";
                        renderPendingBetsTable();
                    }
                }
            }
        }

        // 启动服务
        async function startService() {
            if (isServiceRunning) return;
            
            // 验证API Key
            const apiKeyValid = await verifyApiKey();
            if (!apiKeyValid) {
                alert("API Key验证失败，请检查后重试");
                return;
            }
            
            // 保存当前配置
            saveParameters();
            
            // 更新服务状态
            isServiceRunning = true;
            document.getElementById("serviceStatusIndicator").className = "inline-block w-3 h-3 rounded-full bg-success mr-2";
            document.getElementById("serviceStatusText").textContent = "服务运行中";
            document.getElementById("startServiceBtn").disabled = true;
            document.getElementById("startServiceBtn").className = "flex-1 bg-success hover:bg-success/90 text-white px-4 py-2 rounded-lg transition hover-lift flex items-center justify-center opacity-50 cursor-not-allowed";
            document.getElementById("stopServiceBtn").disabled = false;
            document.getElementById("stopServiceBtn").className = "flex-1 bg-danger hover:bg-danger/90 text-white px-4 py-2 rounded-lg transition hover-lift";
            
            Logger.success("服务已启动");
            
            // 加载投注项目
            await loadBetItems();
            
            // 启动自动刷新
            startAutoRefresh();
            
            // 启动投注检查定时器
            startBetCheckTimer();
            
            // 启动定时任务检查
            startScheduleCheckers();
        }

        // 停止服务
        function stopService() {
            if (!isServiceRunning) return;
            
            // 清除所有定时器
            stopAutoRefresh();
            stopBetCheckTimer();
            stopAllFollowCheckTimers();
            stopScheduleCheckers();
            
            // 更新服务状态
            isServiceRunning = false;
            document.getElementById("serviceStatusIndicator").className = "inline-block w-3 h-3 rounded-full bg-gray-400 mr-2";
            document.getElementById("serviceStatusText").textContent = "服务未运行";
            document.getElementById("startServiceBtn").disabled = false;
            document.getElementById("startServiceBtn").className = "flex-1 bg-success hover:bg-success/90 text-white px-4 py-2 rounded-lg transition hover-lift flex items-center justify-center";
            document.getElementById("stopServiceBtn").disabled = true;
            document.getElementById("stopServiceBtn").className = "flex-1 bg-danger hover:bg-danger/90 text-white px-4 py-2 rounded-lg transition hover-lift opacity-50 cursor-not-allowed";
            
            Logger.warning("服务已停止");
        }

        // 启动自动刷新
        function startAutoRefresh() {
            stopAutoRefresh();
            
            // 计算刷新间隔（毫秒）
            const hours = parseInt(document.getElementById("refreshHoursInput").value) || 0;
            const minutes = parseInt(document.getElementById("refreshMinutesInput").value) || 0;
            const seconds = parseInt(document.getElementById("refreshSecondsInput").value) || 30;
            CONFIG.state.refreshInterval = hours * 3600 + minutes * 60 + seconds;
            const intervalMs = CONFIG.state.refreshInterval * 1000;
            
            // 更新显示
            updateRefreshIntervalDisplay();
            
            // 启动定时器
            autoRefreshTimer = setInterval(() => {
                if (isServiceRunning && CONFIG.state.autoRefresh && isPageVisible) {
                    loadBetItems();
                }
            }, intervalMs);
            
            // 启动倒计时显示
            startRefreshCountdown();
            
            Logger.info(`自动刷新已启动，间隔 ${formatTime(CONFIG.state.refreshInterval)}`, true);
        }

        // 停止自动刷新
        function stopAutoRefresh() {
            if (autoRefreshTimer) {
                clearInterval(autoRefreshTimer);
                autoRefreshTimer = null;
            }
            
            if (countdownTimer) {
                clearInterval(countdownTimer);
                countdownTimer = null;
            }
            
            Logger.info("自动刷新已停止", true);
        }

        // 启动刷新倒计时显示
        function startRefreshCountdown() {
            if (countdownTimer) {
                clearInterval(countdownTimer);
            }
            
            resetRefreshCycle();
            
            countdownTimer = setInterval(() => {
                updateRefreshIntervalDisplay();
            }, 100);
        }

        // 重置刷新周期
        function resetRefreshCycle() {
            refreshCycleStartTime = new Date().getTime();
        }

        // 更新刷新间隔显示
        function updateRefreshIntervalDisplay() {
            const now = new Date().getTime();
            const elapsed = (now - refreshCycleStartTime) / 1000;
            const remaining = Math.max(0, CONFIG.state.refreshInterval - elapsed);
            
            document.getElementById("refreshIntervalDisplay").textContent = formatTimeWithMs(remaining);
        }

        // 格式化时间（带毫秒）
        function formatTimeWithMs(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 1000);
            
            return `${padZero(hours)}:${padZero(minutes)}:${padZero(secs)}.${padZero(ms, 3)}`;
        }

        // 格式化时间（秒转时分秒）
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            let parts = [];
            if (hours > 0) parts.push(`${hours}小时`);
            if (minutes > 0) parts.push(`${minutes}分钟`);
            parts.push(`${secs}秒`);
            
            return parts.join('');
        }

        // 数字补零
        function padZero(num, length = 2) {
            return num.toString().padStart(length, '0');
        }

        // 切换自动刷新
        function toggleAutoRefresh() {
            CONFIG.state.autoRefresh = !CONFIG.state.autoRefresh;
            const btn = document.getElementById("autoRefreshBtn");
            
            if (CONFIG.state.autoRefresh) {
                btn.innerHTML = '<i class="fa fa-refresh mr-1"></i> 关闭自动刷新';
                Logger.info("自动刷新已开启");
                if (isServiceRunning) {
                    startAutoRefresh();
                }
            } else {
                btn.innerHTML = '<i class="fa fa-refresh mr-1"></i> 开启自动刷新';
                Logger.info("自动刷新已关闭");
                if (countdownTimer) {
                    clearInterval(countdownTimer);
                    countdownTimer = null;
                }
            }
        }

        // 手动刷新
        async function manualRefresh() {
            Logger.info("手动刷新数据...");
            await loadBetItems();
        }

        // 启动投注检查定时器
        function startBetCheckTimer() {
            stopBetCheckTimer();
            
            const interval = parseFloat(document.getElementById("checkIntervalInput").value) || 2;
            CONFIG.state.checkInterval = interval;
            
            betCheckTimer = setInterval(() => {
                if (isServiceRunning && isPageVisible) {
                    processPendingBets();
                    checkAndPlaceBets();
                }
            }, interval * 1000);
            
            Logger.info(`投注检查定时器已启动，间隔 ${interval}秒`, true);
        }

        // 停止投注检查定时器
        function stopBetCheckTimer() {
            if (betCheckTimer) {
                clearInterval(betCheckTimer);
                betCheckTimer = null;
                Logger.info("投注检查定时器已停止", true);
            }
        }

        // 停止所有跟随检查定时器
        function stopAllFollowCheckTimers() {
            Object.keys(followCheckTimers).forEach(timerId => {
                clearInterval(followCheckTimers[timerId]);
            });
            followCheckTimers = {};
            Logger.info("所有跟随检查定时器已停止", true);
        }

        // 检查并执行投注
        async function checkAndPlaceBets() {
            if (pendingBets.length === 0) return;
            
            const now = new Date();
            const betsToPlace = pendingBets.filter(bet => 
                bet.status === "等待中" && 
                now >= bet.betTime && 
                now < new Date(bet.endtime).getTime() + CONFIG.state.toleranceSeconds * 1000
            );
            
            if (betsToPlace.length > 0) {
                Logger.info(`发现 ${betsToPlace.length} 个需要执行的投注任务`, true);
                
                for (const bet of betsToPlace) {
                    // 更新状态为处理中
                    const index = pendingBets.findIndex(b => b.id === bet.id && b.status === "等待中");
                    if (index !== -1) {
                        pendingBets[index].status = "处理中";
                        renderPendingBetsTable();
                    }
                    
                    // 执行投注
                    await executeScheduledBet(bet);
                }
            }
        }

        // 执行定时投注
        async function executeScheduledBet(bet) {
            try {
                Logger.info(`执行定时投注项目 #${bet.id}，选项: ${bet.highestOddsTeam}, 金额: ${bet.betAmount}`);
                
                // 找到对应的选项ID
                const option = bet.optionsList.find(opt => opt.text === bet.highestOddsTeam);
                if (!option) {
                    Logger.error(`投注失败: 未找到选项 ${bet.highestOddsTeam}`);
                    
                    // 更新状态
                    const index = pendingBets.findIndex(b => b.id === bet.id && b.status === "处理中");
                    if (index !== -1) {
                        pendingBets[index].status = "失败";
                        renderPendingBetsTable();
                    }
                    
                    return;
                }
                
                // 执行投注请求
                const url = `${CONFIG.mainHost}/${CONFIG.apis.betgameOdds
                    .replace('{optId}', option.id)
                    .replace('{bonus}', bet.betAmount)}`;
                
                const result = await request(url);
                
                // 修复：完善的成功判断
                const isSuccess = checkBetSuccess(result);
                
                if (!isSuccess) {
                    const errorMsg = result.msg || '未知错误';
                    Logger.error(`定时投注失败: ${errorMsg}`);
                    
                    // 更新状态
                    const index = pendingBets.findIndex(b => b.id === bet.id && b.status === "处理中");
                    if (index !== -1) {
                        pendingBets[index].status = "失败";
                        renderPendingBetsTable();
                    }
                    
                    return;
                }
                
                Logger.success(`定时投注成功: 项目 #${bet.id}，选项 ${bet.highestOddsTeam}，金额 ${bet.betAmount}`);
                
                // 记录投注记录
                if (!GlobalInfo.bet_mask[bet.id]) {
                    GlobalInfo.bet_mask[bet.id] = [];
                }
                GlobalInfo.bet_mask[bet.id].push(option.id);
                
                // 更新状态
                const index = pendingBets.findIndex(b => b.id === bet.id && b.status === "处理中");
                if (index !== -1) {
                    pendingBets[index].status = "已完成";
                    renderPendingBetsTable();
                }
                
                // 更新AI预测准确率
                const aiPrediction = AIAnalytics.predictionCache[bet.id];
                if (aiPrediction) {
                    const isCorrect = option.text.includes(aiPrediction.prediction);
                    AIAnalytics.accuracyStats.total++;
                    if (isCorrect) {
                        AIAnalytics.accuracyStats.correct++;
                    }
                    updateAiAccuracyDisplay();
                    Logger.info(`项目 #${bet.id} - AI预测验证: ${isCorrect ? '正确' : '错误'} (当前准确率: ${calculateAiAccuracy()}%)`, true);
                }
                
                // 投注成功后自动刷新
                setTimeout(() => loadBetItems(), 3000);
                
                return true;
            } catch (e) {
                Logger.warning("主服务器定时投注失败，尝试备用服务器...");
                try {
                    // 找到对应的选项ID
                    const option = bet.optionsList.find(opt => opt.text === bet.highestOddsTeam);
                    if (!option) {
                        Logger.error(`备用服务器 - 投注失败: 未找到选项 ${bet.highestOddsTeam}`);
                        
                        // 更新状态
                        const index = pendingBets.findIndex(b => b.id === bet.id && b.status === "处理中");
                        if (index !== -1) {
                            pendingBets[index].status = "失败";
                            renderPendingBetsTable();
                        }
                        
                        return;
                    }
                    
                    const url = `${CONFIG.testHost}/${CONFIG.apis.betgameOdds
                        .replace('{optId}', option.id)
                        .replace('{bonus}', bet.betAmount)}`;
                    
                    const result = await request(url);
                    
                    // 修复：完善的成功判断
                    const isSuccess = checkBetSuccess(result);
                    
                    if (!isSuccess) {
                        const errorMsg = result.msg || '未知错误';
                        Logger.error(`备用服务器 - 定时投注失败: ${errorMsg}`);
                        
                        // 更新状态
                        const index = pendingBets.findIndex(b => b.id === bet.id && b.status === "处理中");
                        if (index !== -1) {
                            pendingBets[index].status = "失败";
                            renderPendingBetsTable();
                        }
                        
                        return;
                    }
                    
                    Logger.success(`备用服务器 - 定时投注成功: 项目 #${bet.id}，选项 ${bet.highestOddsTeam}，金额 ${bet.betAmount}`);
                    
                    // 记录投注记录
                    if (!GlobalInfo.bet_mask[bet.id]) {
                        GlobalInfo.bet_mask[bet.id] = [];
                    }
                    GlobalInfo.bet_mask[bet.id].push(option.id);
                    
                    // 更新状态
                    const index = pendingBets.findIndex(b => b.id === bet.id && b.status === "处理中");
                    if (index !== -1) {
                        pendingBets[index].status = "已完成";
                        renderPendingBetsTable();
                    }
                    
                    // 投注成功后自动刷新
                    setTimeout(() => loadBetItems(), 3000);
                    
                    return true;
                } catch (e2) {
                    Logger.error(`定时投注请求失败: ${e2.message}`);
                    
                    // 更新状态
                    const index = pendingBets.findIndex(b => b.id === bet.id && b.status === "处理中");
                    if (index !== -1) {
                        pendingBets[index].status = "失败";
                        renderPendingBetsTable();
                    }
                    
                    return false;
                }
            }
        }

        // 启动定时任务检查器
        function startScheduleCheckers() {
            stopScheduleCheckers();
            
            // 启动第一组定时任务检查
            if (CONFIG.state.schedule1Enabled) {
                scheduleTimers.check1 = setInterval(() => {
                    checkSchedule(1);
                }, 60000); // 每分钟检查一次
                checkSchedule(1); // 立即执行一次
            }
            
            // 启动第二组定时任务检查
            if (CONFIG.state.schedule2Enabled) {
                scheduleTimers.check2 = setInterval(() => {
                    checkSchedule(2);
                }, 60000); // 每分钟检查一次
                checkSchedule(2); // 立即执行一次
            }
            
            Logger.info("定时任务检查器已启动", true);
        }

        // 停止定时任务检查器
        function stopScheduleCheckers() {
            if (scheduleTimers.check1) {
                clearInterval(scheduleTimers.check1);
                scheduleTimers.check1 = null;
            }
            
            if (scheduleTimers.check2) {
                clearInterval(scheduleTimers.check2);
                scheduleTimers.check2 = null;
            }
            
            Logger.info("定时任务检查器已停止", true);
        }

        // 检查定时任务状态
        function checkSchedule(scheduleNum) {
            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = currentHour * 60 + now.getMinutes();
            
            const start = CONFIG.state[`schedule${scheduleNum}StartTime`].split(':').map(Number);
            const stop = CONFIG.state[`schedule${scheduleNum}StopTime`].split(':').map(Number);
            
            const startMinute = start[0] * 60 + start[1];
            const stopMinute = stop[0] * 60 + stop[1];
            
            let shouldRun = false;
            if (startMinute < stopMinute) {
                shouldRun = currentMinute >= startMinute && currentMinute < stopMinute;
            } else {
                shouldRun = currentMinute >= startMinute || currentMinute < stopMinute;
            }
            
            if (shouldRun && !isServiceRunning) {
                Logger.success(`第${scheduleNum}组定时任务触发 - 启动服务`);
                startService();
            } else if (!shouldRun && isServiceRunning) {
                Logger.success(`第${scheduleNum}组定时任务触发 - 停止服务`);
                stopService();
                
                // 停止后取消勾选
                const checkbox = document.getElementById(`schedule${scheduleNum}EnabledCheckbox`);
                if (checkbox) {
                    checkbox.checked = false;
                    CONFIG.state[`schedule${scheduleNum}Enabled`] = false;
                }
            }
        }

        // 日志弹窗控制
        function toggleLogModal() {
            logModalVisible = !logModalVisible;
            const modal = document.getElementById('logModal');
            if (modal) {
                modal.classList.toggle('hidden', !logModalVisible);
                Logger.render();
            }
        }

        // 更新最后活动时间
        function updateLastActivity() {
            lastActivityTime = new Date().getTime();
        }

        // 处理页面可见性变化
        function handleVisibilityChange() {
            isPageVisible = document.visibilityState === 'visible';
            if (isPageVisible && isServiceRunning) {
                Logger.info("页面恢复可见，同步数据状态", true);
                manualRefresh();
            }
        }

        // 保存参数配置
        function saveParameters() {
            try {
                // 保存旧的刷新间隔用于比较
                const oldRefreshInterval = CONFIG.state.refreshInterval;
                
                // 基础配置
                CONFIG.state.targetUserId = document.getElementById("targetUserIdInput").value || "205809";
                CONFIG.state.advanceSeconds = Math.max(0, parseInt(document.getElementById("advanceSecondsInput").value) || 3);
                CONFIG.state.toleranceSeconds = Math.max(0, parseInt(document.getElementById("toleranceSecondsInput").value) || 10);
                CONFIG.state.baseAmount = Math.max(100, parseInt(document.getElementById("baseAmountInput").value) || 10000); // 只保留基础金额
                CONFIG.state.betStrategy = document.getElementById("betStrategySelect").value || "higher_odds";
                CONFIG.state.checkInterval = Math.max(0.1, parseFloat(document.getElementById("checkIntervalInput").value) || 2);
                CONFIG.state.detailedLogMode = document.getElementById("detailedLogModeCheckbox").checked;
                CONFIG.state.pendingFilter = document.getElementById("pendingFilterSelect").value || "all";
                CONFIG.state.followCheckInterval = Math.max(50, parseInt(document.getElementById("followCheckIntervalInput").value) || 100);
                CONFIG.state.aiPredictionEnabled = document.getElementById("aiPredictionEnabledCheckbox").checked;
                
                // 刷新设置
                const hours = parseInt(document.getElementById("refreshHoursInput").value) || 0;
                const minutes = parseInt(document.getElementById("refreshMinutesInput").value) || 0;
                const seconds = parseInt(document.getElementById("refreshSecondsInput").value) || 30;
                const totalSeconds = hours * 3600 + minutes * 60 + seconds;
                if (totalSeconds >= 5 && totalSeconds <= 86400) {
                    CONFIG.state.refreshInterval = totalSeconds;
                }
                
                // 定时任务配置
                CONFIG.state.schedule1Enabled = document.getElementById("schedule1EnabledCheckbox").checked;
                CONFIG.state.schedule1StartTime = document.getElementById("schedule1StartTimeInput").value || "09:00";
                CONFIG.state.schedule1StopTime = document.getElementById("schedule1StopTimeInput").value || "23:00";
                
                CONFIG.state.schedule2Enabled = document.getElementById("schedule2EnabledCheckbox").checked;
                CONFIG.state.schedule2StartTime = document.getElementById("schedule2StartTimeInput").value || "00:00";
                CONFIG.state.schedule2StopTime = document.getElementById("schedule2StopTimeInput").value || "06:00";
                
                // 更新表单显示
                document.getElementById("advanceSecondsInput").value = CONFIG.state.advanceSeconds;
                document.getElementById("toleranceSecondsInput").value = CONFIG.state.toleranceSeconds;
                document.getElementById("baseAmountInput").value = CONFIG.state.baseAmount;
                document.getElementById("checkIntervalInput").value = CONFIG.state.checkInterval;
                document.getElementById("followCheckIntervalInput").value = CONFIG.state.followCheckInterval;
                
                // 更新日志模式
                Logger.toggleDetailedMode(CONFIG.state.detailedLogMode);
                
                // 计算并显示收益
                calculateProfit();
                
                // 日志记录
                const hms = formatTime(CONFIG.state.refreshInterval);
                Logger.info(`参数配置已保存 - 提前下注: ${CONFIG.state.advanceSeconds}s, 容忍时间: ${CONFIG.state.toleranceSeconds}s, 刷新间隔: ${hms}, 检查间隔: ${CONFIG.state.checkInterval}s, 基础金额: ${CONFIG.state.baseAmount}`);
                
                // 更新定时任务
                setupSchedules();
                
                if (isServiceRunning) {
                    flushConfig().then(() => {
                        processPendingBets(true);
                        renderBetTable();
                        renderPendingBetsTable();
                        
                        startBetCheckTimer();
                        
                        // 刷新间隔改变时重置周期
                        if (oldRefreshInterval !== CONFIG.state.refreshInterval) {
                            resetRefreshCycle();
                            startAutoRefresh();
                        }
                        
                        // 跟随模式切换处理
                        if (CONFIG.state.betStrategy === "follow") {
                            CONFIG.state.availableBets.forEach(bet => {
                                startSmartFollowingCheck(bet.id);
                            });
                        } else {
                            stopAllFollowCheckTimers();
                        }
                    });
                } else {
                    // 更新刷新间隔显示
                    updateRefreshIntervalDisplay();
                }
                
                return true;
            } catch (e) {
                Logger.error(`保存参数失败: ${e.message}`);
                return false;
            }
        }

        // 设置定时任务
        function setupSchedules() {
            clearSchedules();
            
            // 第一组定时任务
            if (CONFIG.state.schedule1Enabled) {
                setupSingleSchedule(1);
            }
            
            // 第二组定时任务
            if (CONFIG.state.schedule2Enabled) {
                setupSingleSchedule(2);
            }
        }

        // 设置单个定时任务
        function setupSingleSchedule(scheduleNum) {
            Logger.info(`启用第${scheduleNum}组定时任务 - 开始: ${CONFIG.state[`schedule${scheduleNum}StartTime`]}, 结束: ${CONFIG.state[`schedule${scheduleNum}StopTime`]}`);
            
            const checkSchedule = () => {
                const now = new Date();
                const currentTime = now.getHours() * 60 + now.getMinutes();
                const [startH, startM] = CONFIG.state[`schedule${scheduleNum}StartTime`].split(':').map(Number);
                const [stopH, stopM] = CONFIG.state[`schedule${scheduleNum}StopTime`].split(':').map(Number);
                
                const startTime = startH * 60 + startM;
                const stopTime = stopH * 60 + stopM;
                
                const shouldRun = stopTime > startTime 
                    ? currentTime >= startTime && currentTime < stopTime
                    : currentTime >= startTime || currentTime < stopTime;
                
                if (shouldRun && !isServiceRunning) {
                    Logger.success(`第${scheduleNum}组定时任务触发 - 启动服务`);
                    startService();
                } else if (!shouldRun && isServiceRunning) {
                    Logger.success(`第${scheduleNum}组定时任务触发 - 停止服务`);
                    stopService();
                    
                    // 停止后取消勾选
                    const checkbox = document.getElementById(`schedule${scheduleNum}EnabledCheckbox`);
                    if (checkbox) {
                        checkbox.checked = false;
                        CONFIG.state[`schedule${scheduleNum}Enabled`] = false;
                    }
                    
                    clearTimeout(scheduleTimers[`check${scheduleNum}`]);
                    scheduleTimers[`check${scheduleNum}`] = null;
                } else {
                    scheduleTimers[`check${scheduleNum}`] = setTimeout(checkSchedule, 5000);
                }
            };
            
            checkSchedule();
        }

        // 清除所有定时任务
        function clearSchedules() {
            if (scheduleTimers.check1) {
                clearTimeout(scheduleTimers.check1);
                scheduleTimers.check1 = null;
            }
            
            if (scheduleTimers.check2) {
                clearTimeout(scheduleTimers.check2);
                scheduleTimers.check2 = null;
            }
        }

        // 初始化页面
        window.onload = function() {
            // 初始化收益计算
            calculateProfit();
            
            // 初始化刷新间隔显示
            updateRefreshIntervalDisplay();
            
            // 设置初始表单值
            const hms = formatTime(CONFIG.state.refreshInterval).split(/小时|分钟|秒/).filter(Boolean);
            document.getElementById("refreshHoursInput").value = hms.length >= 1 ? parseInt(hms[0]) : 0;
            document.getElementById("refreshMinutesInput").value = hms.length >= 2 ? parseInt(hms[1]) : 0;
            document.getElementById("refreshSecondsInput").value = hms.length >= 3 ? parseInt(hms[2]) : 30;
            
            document.getElementById("targetUserIdInput").value = CONFIG.state.targetUserId;
            document.getElementById("advanceSecondsInput").value = CONFIG.state.advanceSeconds;
            document.getElementById("toleranceSecondsInput").value = CONFIG.state.toleranceSeconds;
            document.getElementById("baseAmountInput").value = CONFIG.state.baseAmount;
            document.getElementById("betStrategySelect").value = CONFIG.state.betStrategy;
            document.getElementById("checkIntervalInput").value = CONFIG.state.checkInterval;
            document.getElementById("detailedLogModeCheckbox").checked = CONFIG.state.detailedLogMode;
            document.getElementById("pendingFilterSelect").value = CONFIG.state.pendingFilter;
            document.getElementById("followCheckIntervalInput").value = CONFIG.state.followCheckInterval;
            document.getElementById("aiPredictionEnabledCheckbox").checked = CONFIG.state.aiPredictionEnabled;
            
            document.getElementById("schedule1EnabledCheckbox").checked = CONFIG.state.schedule1Enabled;
            document.getElementById("schedule1StartTimeInput").value = CONFIG.state.schedule1StartTime;
            document.getElementById("schedule1StopTimeInput").value = CONFIG.state.schedule1StopTime;
            
            document.getElementById("schedule2EnabledCheckbox").checked = CONFIG.state.schedule2Enabled;
            document.getElementById("schedule2StartTimeInput").value = CONFIG.state.schedule2StartTime;
            document.getElementById("schedule2StopTimeInput").value = CONFIG.state.schedule2StopTime;
            
            // 初始化表格
            renderBetTable();
            renderPendingBetsTable();
            
            // 初始化日志
            Logger.info("系统已加载，等待启动服务...");
            
            // 设置页面可见性监听
            document.addEventListener('visibilitychange', handleVisibilityChange);
            
            // 设置定时任务
            setupSchedules();
        };
    </script>
</body>
</html>
