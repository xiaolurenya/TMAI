<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M-Team 馒头菠菜</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/axios@1.6.2/dist/axios.min.js"></script>
    <script>
        // 配置Tailwind自定义样式
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#165DFF',
                        secondary: '#36CFC9',
                        success: '#52C41A',
                        warning: '#FAAD14',
                        danger: '#FF4D4F',
                        dark: '#1F2937',
                        light: '#F9FAFB',
                        purple: '#7B61FF'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .card-shadow {
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            }
            .hover-lift {
                transition: transform 0.2s, box-shadow 0.2s;
            }
            .hover-lift:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 16px rgba(0, 0, 0, 0.08);
            }
            .table-hover-row:hover {
                background-color: rgba(22, 93, 255, 0.03);
            }
            .odds-highlight {
                background-color: rgba(82, 196, 26, 0.1);
                font-weight: bold;
            }
            .follower-indicator {
                position: relative;
                padding-left: 1.5rem;
            }
            .follower-indicator::before {
                content: "→";
                position: absolute;
                left: 0;
                color: #7B61FF;
                font-weight: bold;
            }
            .debug-log {
                color: #9CA3AF;
            }
        }
    </style>
    <script>
        // 安全机制 - 防调试和防复制
        (function() {
            const antiDebug = () => {
                if (window.outerHeight - window.innerHeight > 200 || window.outerWidth - window.innerWidth > 200) {
                    document.body.innerHTML = '<div class="flex items-center justify-center h-screen bg-danger text-white text-xl">检测到非法调试行为，系统已保护</div>';
                    return;
                }
                requestAnimationFrame(antiDebug);
            };
            antiDebug();

            document.addEventListener('contextmenu', e => e.preventDefault());
            document.addEventListener('selectstart', e => e.preventDefault());
            document.addEventListener('keydown', e => {
                if (e.key === 'F12' || (e.ctrlKey && e.shiftKey && e.key === 'I')) {
                    e.preventDefault();
                    alert('禁止调试');
                }
            });
        })();

        if (typeof axios === 'undefined') {
            document.write('<script src="https://unpkg.com/axios@1.6.2/dist/axios.min.js"><\/script>');
        }

        // 音频提示系统
        const AudioPlayer = {
            sounds: {
                scheduleStart: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-correct-answer-tone-2870.mp3'),
                scheduleStop: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-alarm-digital-clock-beep-989.mp3'),
                betSuccess: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-achievement-bell-600.mp3')
            },
            
            playScheduleStart() {
                this.sounds.scheduleStart.currentTime = 0;
                this.sounds.scheduleStart.play().catch(e => {
                    Logger.warning("提示音播放失败: " + e.message, true);
                });
            },
            
            playScheduleStop() {
                this.sounds.scheduleStop.currentTime = 0;
                this.sounds.scheduleStop.play().catch(e => {
                    Logger.warning("提示音播放失败: " + e.message, true);
                });
            },
            
            playBetSuccess() {
                this.sounds.betSuccess.currentTime = 0;
                this.sounds.betSuccess.play().catch(e => {
                    Logger.warning("提示音播放失败: " + e.message, true);
                });
            }
        };

        // 全局状态封装（优化全局变量泛滥问题）
        const AppState = {
            autoRefreshTimer: null,
            betCheckTimer: null,
            followCheckTimers: {},
            pendingBets: [],
            isServiceRunning: false,
            logModalVisible: false,
            lastActivityTime: 0,
            isPageVisible: true,
            countdownTimer: null,
            refreshCycleStartTime: 0,
            scheduleTimers: { check: null },
            fiveMinCheckTimer: null,
            isBettingInProgress: false,
            isServiceStartedByCheck: false,
            
            // 状态访问器
            setServiceRunning(status) {
                this.isServiceRunning = status;
                updateServiceStatus();
            },
            getServiceRunning() {
                return this.isServiceRunning;
            },
            setBettingInProgress(status) {
                this.isBettingInProgress = status;
            },
            getBettingInProgress() {
                return this.isBettingInProgress;
            },
            clearFollowTimers() {
                Object.values(this.followCheckTimers).forEach(timer => clearInterval(timer));
                this.followCheckTimers = {};
            }
        };

        const FIVE_MINUTES = 5 * 60 * 1000;
        const BET_WARN_TIME = 10 * 60 * 1000;
        
        // AI分析相关数据存储（新增缓存时间戳）
        const AIAnalytics = {
            historicalData: {},
            predictionCache: {} // 结构：{gameId: {prediction, confidence, timestamp}}
        };
        
        const GlobalInfo = {
            bet_mask: {},
            available_bets: [],
            my_bet_log: [],
            configs: {},
            followedBets: {}
        };

        // 日志系统（优化分级控制）
        const Logger = {
            logs: [],
            detailedMode: false,
            log(content, level = "INFO", isDebug = false) {
                if (isDebug && !this.detailedMode) return;
                
                const now = new Date().toLocaleString("zh-CN", {
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    fractionalSecondDigits: 3
                });
                const logItem = `[${now}] [${level}] ${content}`;
                this.logs.unshift(logItem);
                if (this.logs.length > 500) this.logs.pop();
                this.render();
            },
            info(content, isDebug = false) { this.log(content, "INFO", isDebug); },
            error(content, isDebug = false) { this.log(content, "ERROR", isDebug); },
            warning(content, isDebug = false) { this.log(content, "WARN", isDebug); },
            debug(content) { this.log(content, "DEBUG", true); },
            clear() {
                this.logs = [];
                this.render();
                this.info("日志已清空");
            },
            render() {
                const mainPanel = document.getElementById('logPanel');
                if (mainPanel) {
                    mainPanel.innerHTML = this.logs.map(log => {
                        const isError = log.includes('[ERROR]');
                        const isWarn = log.includes('[WARN]');
                        const isDebug = log.includes('[DEBUG]');
                        let className = "text-sm py-1";
                        if (isError) className += " text-danger";
                        else if (isWarn) className += " text-warning";
                        else if (isDebug) className += " debug-log";
                        return `<div class="${className}">${log}</div>`;
                    }).join("");
                    mainPanel.scrollTop = mainPanel.scrollHeight;
                }
                
                const modalPanel = document.getElementById('logModalPanel');
                if (modalPanel) {
                    modalPanel.innerHTML = this.logs.map(log => {
                        const isError = log.includes('[ERROR]');
                        const isWarn = log.includes('[WARN]');
                        const isDebug = log.includes('[DEBUG]');
                        let className = "text-sm py-1";
                        if (isError) className += " text-danger";
                        else if (isWarn) className += " text-warning";
                        else if (isDebug) className += " debug-log";
                        return `<div class="${className}">${log}</div>`;
                    }).join("");
                    modalPanel.scrollTop = modalPanel.scrollHeight;
                }
            },
            toggleDetailedMode(enabled) {
                this.detailedMode = enabled;
                this.info(`详细日志模式已${enabled ? '开启' : '关闭'}`, true);
            }
        };

        // 配置
        const CONFIG = {
            mainHost: "https://api.m-team.io/api",
            testHost: "https://test2.m-team.cc/api",
            apis: {
                "get_current_bet": "bet/findBetgameList?active=LIVE&fix=0",
                "betgameOdds": "bet/betgameOdds?optId={optId}&bonus={bonus}",
                "get_details": "bet/getDetail?gameId={gameId}",
                "get_gamblers": "bet/getDetailBetList?gameId={gameId}",
                "get_my_bet_log": "bet/myCouponLog",
                "get_team_history": "team/getHistory?teamId={teamId}"
            },
            state: {
                availableBets: [],
                autoRefresh: true,
                refreshInterval: 30,
                targetUserId: "205809",
                advanceSeconds: 3,
                amountRange: 100,
                baseAmount: 1000,
                betStrategy: "higher_odds",
                checkInterval: 2,
                detailedLogMode: false,
                pendingFilter: "all",
                aiPredictionEnabled: true,
                followCheckInterval: 500,
                scheduleEnabled: false,
                scheduleStartTime: "09:00",
                scheduleStopTime: "23:00"
            }
        };

        // API Key加密存储工具
        const ApiKeyManager = {
            save(key) {
                if (!key) return;
                const encrypted = btoa(key);
                localStorage.setItem('mt_api_key', encrypted);
            },
            get() {
                const encrypted = localStorage.getItem('mt_api_key') || "";
                try {
                    return atob(encrypted);
                } catch (e) {
                    return "";
                }
            },
            clear() {
                localStorage.removeItem('mt_api_key');
            }
        };

        // 核心请求函数（优化API Key传输）
        async function request(url, method = 'post', data = {}, retry = 1) {
            try {
                const apiKey = ApiKeyManager.get() || document.getElementById("apiKeyInput").value || "";
                const response = await axios({
                    method,
                    url,
                    data,
                    headers: {
                        "x-api-key": apiKey,
                        "Content-Type": "application/json"
                    },
                    timeout: 15000
                });
                Logger.debug(`请求成功: ${url}`);
                return response.data;
            } catch (e) {
                Logger.error(`请求失败: ${e.message} (${url})`, true);
                if (retry > 0) {
                    Logger.warning(`尝试重试请求: ${url}`, true);
                    return request(url, method, data, retry - 1);
                }
                throw new Error(`请求失败: ${e.message}`);
            }
        }

        // API验证逻辑
        async function verifyApiKey() {
            const apiKey = document.getElementById("apiKeyInput").value;
            if (!apiKey) {
                Logger.warning("请输入API Key");
                return false;
            }
            // 保存API Key到本地
            ApiKeyManager.save(apiKey);

            try {
                Logger.info("正在验证API Key（通过获取投注列表）...");
                const result = await request(`${CONFIG.mainHost}/${CONFIG.apis.get_current_bet}`);
                if (result && (result.data || result.code === 0)) {
                    Logger.info("API Key验证成功");
                    
                    Logger.info("API验证成功，开始自动刷新可投注项目...");
                    const refreshSuccess = await loadBetItems();
                    if (!refreshSuccess) {
                        Logger.warning("API验证成功，但数据刷新失败，将重试一次...");
                        await loadBetItems();
                    }
                    
                    setTimeout(() => {
                        Logger.info("API验证后延迟4秒，启动5分钟自动检测机制");
                        startFiveMinCheckTimer();
                    }, 4000);
                    
                    return true;
                } else {
                    Logger.error(`API Key验证失败: 响应格式不正确`);
                    return false;
                }
            } catch (e) {
                Logger.warning("主服务器验证失败，尝试备用服务器...");
                try {
                    const result = await request(`${CONFIG.testHost}/${CONFIG.apis.get_current_bet}`);
                    if (result && (result.data || result.code === 0)) {
                        Logger.info("备用服务器API Key验证成功");
                        
                        Logger.info("备用服务器API验证成功，开始自动刷新可投注项目...");
                        const refreshSuccess = await loadBetItems();
                        if (!refreshSuccess) {
                            Logger.warning("备用服务器API验证成功，但数据刷新失败，将重试一次...");
                            await loadBetItems();
                        }
                        
                        setTimeout(() => {
                            Logger.info("API验证后延迟4秒，启动5分钟自动检测机制");
                            startFiveMinCheckTimer();
                        }, 4000);
                        
                        return true;
                    } else {
                        Logger.error(`备用服务器API Key验证失败: 响应格式不正确`);
                        return false;
                    }
                } catch (e2) {
                    Logger.error(`API Key验证失败: ${e2.message}`);
                    return false;
                }
            }
        }

        // 字符串哈希函数（改为独立函数，避免原型污染）
        function stringHashCode(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash);
        }

        // 获取可投注项目（优化AI分析重复执行）
        async function loadBetItems() {
            updateLastActivity();
            try {
                Logger.debug("正在获取可投注项目...");
                const data = await request(`${CONFIG.mainHost}/${CONFIG.apis.get_current_bet}`);
                CONFIG.state.availableBets = Array.isArray(data?.data) ? data.data : [];
                GlobalInfo.available_bets = CONFIG.state.availableBets;
                
                Logger.info(`找到可下注项目（${CONFIG.state.availableBets.length} 个）`);
                CONFIG.state.availableBets.forEach((betitem, idx) => {
                    Logger.info(`[ ${idx + 1} / ${CONFIG.state.availableBets.length} ] 项目id: ${betitem.id} 结束时间： ${betitem.endtime}`);
                    Logger.info(`${betitem.heading}, ${betitem.undertext || ''}`);
                    
                    if (betitem.optionsList && betitem.optionsList.length > 0) {
                        Logger.debug(`可下注选项(共${betitem.optionsList.length}个)：`);
                        betitem.optionsList.forEach((opt, optIdx) => {
                            Logger.debug(`  [${optIdx + 1}] ${opt.text} (赔率: ${opt.odds})`);
                        });
                    }
                    
                    // AI分析：新增缓存判断，避免重复执行
                    if (CONFIG.state.betStrategy !== "follow" && CONFIG.state.aiPredictionEnabled) {
                        const cache = AIAnalytics.predictionCache[betitem.id];
                        // 缓存不存在或过期（10分钟）时重新分析
                        if (!cache || (Date.now() - cache.timestamp) > 600000) {
                            analyzeWithAI(betitem);
                        }
                    }
                    
                    if (CONFIG.state.betStrategy === "follow" && AppState.getServiceRunning()) {
                        startFollowingCheck(betitem.id);
                    }
                });
                
                await flushConfig();
                processPendingBets(true);
                renderBetTable();
                resetRefreshCycle();
                return true;
            } catch (e) {
                Logger.warning("主服务器获取失败，尝试备用服务器...");
                try {
                    const data = await request(`${CONFIG.testHost}/${CONFIG.apis.get_current_bet}`);
                    CONFIG.state.availableBets = Array.isArray(data?.data) ? data.data : [];
                    GlobalInfo.available_bets = CONFIG.state.availableBets;
                    
                    Logger.info(`从备用服务器找到可下注项目（${CONFIG.state.availableBets.length} 个）`);
                    
                    await flushConfig();
                    processPendingBets(true);
                    renderBetTable();
                    resetRefreshCycle();
                    return true;
                } catch (e2) {
                    Logger.error(`获取投注项目失败: ${e2.message}`);
                    resetRefreshCycle();
                    return false;
                }
            }
        }

        // 刷新配置
        async function flushConfig() {
            const availableBets = GlobalInfo.available_bets;
            const newConfigs = {};
            
            GlobalInfo.bet_mask = {};
            
            availableBets.forEach(bet => {
                const id = bet.id;
                GlobalInfo.bet_mask[id] = [];
                
                const endTime = new Date(bet.endtime);
                const scheduledTime = new Date(endTime.getTime() - CONFIG.state.advanceSeconds * 1000);
                const scheduledTimeMulti = new Date(endTime.getTime() - CONFIG.state.advanceSeconds * 1000);
                
                newConfigs[id] = {
                    bet_id: id,
                    desc: `${bet.heading}, ${bet.undertext || ''}`,
                    scheduled_time: scheduledTime,
                    scheduled_time_multi: scheduledTimeMulti,
                    endtime: bet.endtime,
                    bias: CONFIG.state.advanceSeconds,
                    bonus: CONFIG.state.baseAmount,
                    option_type: CONFIG.state.betStrategy
                };
            });
            
            GlobalInfo.configs = newConfigs;
            Logger.debug(`配置已刷新，应用统一提前下注(${CONFIG.state.advanceSeconds}s)`);
        }

        // 处理待投注项目
        function processPendingBets(refresh = false) {
            const now = new Date();
            const processingItems = refresh ? AppState.pendingBets.filter(bet => bet.status === "处理中") : [];
            let newPendingBets = [...processingItems];
            
            const candidateBets = [];
            Object.values(GlobalInfo.configs).forEach(cfg => {
                if (processingItems.some(bet => bet.id === cfg.bet_id)) {
                    return;
                }
                
                try {
                    const betItem = CONFIG.state.availableBets.find(item => item.id === cfg.bet_id);
                    if (!betItem) return;
                    
                    if (CONFIG.state.betStrategy === "follow") {
                        return;
                    }
                    
                    const betTime = cfg.scheduled_time;
                    if (betTime > now) {
                        if (shouldPlaceBet(betItem)) {
                            const aiPrediction = AIAnalytics.predictionCache[betItem.id];
                            const selectedOption = aiPrediction 
                                ? betItem.optionsList.find(opt => opt.text.includes(aiPrediction.prediction))
                                : getHighestOddsOption(betItem);
                            
                            const betAmount = calculateBetAmount();
                            const odds = selectedOption ? parseFloat(selectedOption.odds) : 0;
                            const ratioValue = odds * betAmount;
                            
                            candidateBets.push({
                                ...betItem,
                                id: cfg.bet_id,
                                betTime,
                                betAmount,
                                strategy: CONFIG.state.betStrategy,
                                status: "等待中",
                                highestOdds: odds,
                                highestOddsTeam: selectedOption ? selectedOption.text : 'N/A',
                                ratioValue: ratioValue,
                                recordedOdds: odds,
                                aiPrediction: aiPrediction ? `${aiPrediction.prediction} (${(aiPrediction.confidence * 100).toFixed(1)}%)` : null
                            });
                        }
                    }
                } catch (e) {
                    Logger.error(`处理项目 #${cfg.bet_id} 失败: ${e.message}`, true);
                }
            });
            
            let selectedBets = [];
            const betsByTimeGroup = {};
            candidateBets.forEach(bet => {
                const timeGroup = new Date(bet.betTime).toLocaleString('zh-CN', { 
                    year: 'numeric', 
                    month: '2-digit', 
                    day: '2-digit', 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                
                if (!betsByTimeGroup[timeGroup]) {
                    betsByTimeGroup[timeGroup] = [];
                }
                betsByTimeGroup[timeGroup].push(bet);
            });
            
            switch (CONFIG.state.pendingFilter) {
                case "all":
                    Object.values(betsByTimeGroup).forEach(group => {
                        selectedBets.push(...group);
                        Logger.debug(`时间组 ${new Date(group[0].betTime).toLocaleString()} 选择所有 ${group.length} 个项目`);
                    });
                    break;
                    
                case "highest_odds":
                    Object.values(betsByTimeGroup).forEach(group => {
                        if (group.length === 0) return;
                        const selected = group.reduce((max, bet) => bet.highestOdds > max.highestOdds ? bet : max, group[0]);
                        selectedBets.push(selected);
                        Logger.debug(`时间组 ${new Date(group[0].betTime).toLocaleString()} 选择最高赔率项目 #${selected.id} (${selected.highestOdds})`);
                    });
                    break;
                    
                case "highest_amount":
                    Object.values(betsByTimeGroup).forEach(group => {
                        if (group.length === 0) return;
                        const selected = group.reduce((max, bet) => bet.betAmount > max.betAmount ? bet : max, group[0]);
                        selectedBets.push(selected);
                        Logger.debug(`时间组 ${new Date(group[0].betTime).toLocaleString()} 选择最高金额项目 #${selected.id} (${selected.betAmount})`);
                    });
                    break;
                    
                case "ratio_based":
                    Object.values(betsByTimeGroup).forEach(group => {
                        if (group.length === 0) return;
                        const selected = group.reduce((max, bet) => bet.ratioValue > max.ratioValue ? bet : max, group[0]);
                        selectedBets.push(selected);
                        Logger.debug(`时间组 ${new Date(group[0].betTime).toLocaleString()} 选择最佳比例项目 #${selected.id} (${selected.ratioValue.toFixed(2)})`);
                    });
                    break;
            }
            
            newPendingBets = [...newPendingBets, ...selectedBets];
            newPendingBets.sort((a, b) => a.betTime - b.betTime);
            AppState.pendingBets = newPendingBets;
            renderPendingBetsTable();
        }

        // 获取目标用户的投注记录
        async function getTargetUserBet(gameId) {
            try {
                Logger.debug(`尝试获取目标用户 ${CONFIG.state.targetUserId} 的投注记录 (项目 #${gameId})`);
                const url = `${CONFIG.mainHost}/${CONFIG.apis.get_gamblers.replace('{gameId}', gameId)}`;
                const data = await request(url);
                
                if (data?.data && Array.isArray(data.data)) {
                    const targetBet = data.data.find(log => log.userid === CONFIG.state.targetUserId);
                    if (targetBet) {
                        Logger.debug(`找到目标用户 ${CONFIG.state.targetUserId} 的投注记录: 选项 ${targetBet.optionid}, 金额 ${targetBet.bonus}`);
                    } else {
                        Logger.debug(`未找到目标用户 ${CONFIG.state.targetUserId} 的投注记录`);
                    }
                    return targetBet;
                }
                return null;
            } catch (e) {
                Logger.warning(`获取用户投注记录失败: ${e.message}，尝试备用服务器`, true);
                try {
                    const url = `${CONFIG.testHost}/${CONFIG.apis.get_gamblers.replace('{gameId}', gameId)}`;
                    const data = await request(url);
                    
                    if (data?.data && Array.isArray(data.data)) {
                        const targetBet = data.data.find(log => log.userid === CONFIG.state.targetUserId);
                        return targetBet;
                    }
                    return null;
                } catch (e2) {
                    Logger.error(`获取用户投注记录失败: ${e2.message}`, true);
                    return null;
                }
            }
        }

        // 启动跟随检查（优化定时器管理）
        function startFollowingCheck(gameId) {
            if (AppState.followCheckTimers[gameId]) {
                clearInterval(AppState.followCheckTimers[gameId]);
            }
            
            if (GlobalInfo.followedBets[gameId]) {
                return;
            }
            
            const checkInterval = CONFIG.state.followCheckInterval;
            Logger.debug(`开始实时监控项目 #${gameId} 的目标用户投注 (检查间隔: ${checkInterval}ms)`);
            
            AppState.followCheckTimers[gameId] = setInterval(async () => {
                if (!AppState.getServiceRunning()) {
                    clearInterval(AppState.followCheckTimers[gameId]);
                    delete AppState.followCheckTimers[gameId];
                    return;
                }
                
                const betItem = CONFIG.state.availableBets.find(item => item.id === gameId);
                if (!betItem) {
                    clearInterval(AppState.followCheckTimers[gameId]);
                    delete AppState.followCheckTimers[gameId];
                    Logger.debug(`项目 #${gameId} 已失效，停止监控`);
                    return;
                }
                
                const endTime = new Date(betItem.endtime);
                const now = new Date();
                if (now > endTime) {
                    clearInterval(AppState.followCheckTimers[gameId]);
                    delete AppState.followCheckTimers[gameId];
                    Logger.debug(`项目 #${gameId} 已过投注时间，停止监控`);
                    return;
                }
                
                const targetBet = await getTargetUserBet(gameId);
                if (targetBet) {
                    const option = betItem.optionsList.find(opt => opt.id === targetBet.optionid);
                    if (!option) {
                        Logger.error(`跟随投注失败: 选项 ${targetBet.optionid} 不存在`);
                        clearInterval(AppState.followCheckTimers[gameId]);
                        delete AppState.followCheckTimers[gameId];
                        return;
                    }
                    
                    Logger.info(`检测到目标用户 ${CONFIG.state.targetUserId} 已投注项目 #${gameId} - ${option.text}，准备立即跟随`);
                    
                    const followBet = {
                        ...betItem,
                        id: gameId,
                        betTime: now,
                        betAmount: calculateFollowAmount(targetBet.bonus),
                        strategy: "follow",
                        status: "处理中",
                        highestOddsTeam: option.text,
                        highestOdds: parseFloat(option.odds || 0),
                        ratioValue: 0,
                        recordedOdds: 0
                    };
                    
                    AppState.pendingBets.unshift(followBet);
                    renderPendingBetsTable();
                    
                    const success = await placeFollowBet(followBet, targetBet.optionid);
                    
                    const index = AppState.pendingBets.findIndex(b => b.id === gameId && b.status === "处理中");
                    if (index !== -1) {
                        AppState.pendingBets[index].status = success ? "已完成" : "失败";
                        renderPendingBetsTable();
                    }
                    
                    if (success) {
                        GlobalInfo.followedBets[gameId] = {
                            optionId: targetBet.optionid,
                            amount: followBet.betAmount
                        };
                        AudioPlayer.playBetSuccess();
                        Logger.info(`跟随投注成功，3秒后自动刷新可投注项目...`);
                        setTimeout(() => loadBetItems(), 3000);
                    }
                    
                    clearInterval(AppState.followCheckTimers[gameId]);
                    delete AppState.followCheckTimers[gameId];
                }
            }, checkInterval);
        }

        // 计算跟随金额（修复金额异常问题）
        function calculateFollowAmount(baseAmount) {
            // 目标金额无效时，使用基础金额作为基数
            const base = parseInt(baseAmount) || CONFIG.state.baseAmount;
            // 确保基数不低于最小投注额
            if (base < 100) return CONFIG.state.baseAmount;
            const bias = Math.floor(Math.random() * (CONFIG.state.amountRange * 2 + 1)) - CONFIG.state.amountRange;
            return Math.max(base + bias, 100);
        }

        // 执行跟随投注
        async function placeFollowBet(betItem, optionId) {
            updateLastActivity();
            try {
                Logger.info(`开始跟随投注项目 #${betItem.id}，选项: ${betItem.highestOddsTeam}, 金额: ${betItem.betAmount}`);
                
                const option = betItem.optionsList.find(opt => opt.id === optionId);
                if (!option) {
                    Logger.error(`跟随投注失败: 选项 ${optionId} 不存在`);
                    return false;
                }
                
                const url = `${CONFIG.mainHost}/${CONFIG.apis.betgameOdds
                    .replace('{optId}', optionId)
                    .replace('{bonus}', betItem.betAmount)}`;
                
                const result = await request(url);
                
                if (result.code !== 0) {
                    Logger.error(`跟随投注失败: ${result.msg || '未知错误'}`);
                    return false;
                }
                
                Logger.info(`跟随投注成功: 项目 #${betItem.id}，选项 ${betItem.highestOddsTeam}，金额 ${betItem.betAmount}`);
                
                if (!GlobalInfo.bet_mask[betItem.id]) {
                    GlobalInfo.bet_mask[betItem.id] = [];
                }
                GlobalInfo.bet_mask[betItem.id].push(optionId);
                
                return true;
            } catch (e) {
                Logger.warning("主服务器跟随投注失败，尝试备用服务器...");
                try {
                    const url = `${CONFIG.testHost}/${CONFIG.apis.betgameOdds
                        .replace('{optId}', optionId)
                        .replace('{bonus}', betItem.betAmount)}`;
                    
                    const result = await request(url);
                    
                    if (result.code !== 0) {
                        Logger.error(`备用服务器跟随投注失败: ${result.msg || '未知错误'}`);
                        return false;
                    }
                    
                    Logger.info(`备用服务器跟随投注成功: 项目 #${betItem.id}`);
                    
                    if (!GlobalInfo.bet_mask[betItem.id]) {
                        GlobalInfo.bet_mask[betItem.id] = [];
                    }
                    GlobalInfo.bet_mask[betItem.id].push(optionId);
                    
                    return true;
                } catch (e2) {
                    Logger.error(`跟随投注请求失败: ${e2.message}`);
                    return false;
                }
            }
        }

        // 获取最高赔率选项
        function getHighestOddsOption(betItem) {
            if (!betItem.optionsList || betItem.optionsList.length === 0) return null;
            
            let highestOdds = -Infinity;
            let highestOption = null;
            
            betItem.optionsList.forEach(option => {
                const odds = parseFloat(option.odds);
                if (odds > highestOdds) {
                    highestOdds = odds;
                    highestOption = option;
                }
            });
            
            return highestOption;
        }

        // 获取押大选项
        async function getLargerOptions(gameId) {
            try {
                const url = `${CONFIG.mainHost}/${CONFIG.apis.get_details.replace('{gameId}', gameId)}`;
                const data = await request(url);
                
                if (!data?.data || !data.data.optionsList) return [];
                
                const options = data.data.optionsList;
                if (options.length > 3) return [];
                
                let minOddsIndex = 0;
                options.forEach((opt, idx) => {
                    if (parseFloat(opt.odds) <= parseFloat(options[minOddsIndex].odds)) {
                        minOddsIndex = idx;
                    }
                });
                
                return options.filter((_, idx) => idx !== minOddsIndex).map(opt => opt.id);
            } catch (e) {
                Logger.error(`获取押大选项失败: ${e.message}`, true);
                return [];
            }
        }

        // 获取押小选项
        async function getSmallerOptions(gameId) {
            try {
                const url = `${CONFIG.mainHost}/${CONFIG.apis.get_details.replace('{gameId}', gameId)}`;
                const data = await request(url);
                
                if (!data?.data || !data.data.optionsList) return [];
                
                const options = data.data.optionsList;
                if (options.length > 3) return [];
                
                let maxOddsIndex = 0;
                options.forEach((opt, idx) => {
                    if (parseFloat(opt.odds) >= parseFloat(options[maxOddsIndex].odds)) {
                        maxOddsIndex = idx;
                    }
                });
                
                return options.filter((_, idx) => idx !== maxOddsIndex).map(opt => opt.id);
            } catch (e) {
                Logger.error(`获取押小选项失败: ${e.message}`, true);
                return [];
            }
        }

        // AI分析模块
        async function analyzeWithAI(betItem) {
            try {
                Logger.debug(`开始AI分析项目 #${betItem.id}...`);
                
                const teams = betItem.optionsList.map(opt => opt.text.trim());
                const teamDataPromises = teams.map(team => fetchTeamHistory(team));
                const teamDataArray = await Promise.all(teamDataPromises);
                
                const prediction = predictWinner(teamDataArray, teams, betItem);
                // 新增缓存时间戳
                AIAnalytics.predictionCache[betItem.id] = {
                    ...prediction,
                    timestamp: Date.now()
                };
                
                Logger.debug(`AI分析完成项目 #${betItem.id}: 预测 ${prediction.prediction} (可信度: ${(prediction.confidence * 100).toFixed(1)}%)`);
                renderBetTable();
                return prediction;
            } catch (e) {
                Logger.warning(`项目 #${betItem.id} 的AI分析失败: ${e.message}`, true);
                return null;
            }
        }

        // 获取队伍历史数据
        async function fetchTeamHistory(teamName) {
            const teamId = stringHashCode(teamName);
            
            if (AIAnalytics.historicalData[teamId]) {
                return AIAnalytics.historicalData[teamId];
            }
            
            try {
                const mockData = {
                    teamName,
                    wins: Math.floor(Math.random() * 30) + 10,
                    losses: Math.floor(Math.random() * 20) + 5,
                    recentScores: Array.from({length: 5}, () => ({
                        score: Math.floor(Math.random() * 20) + 50,
                        opponentScore: Math.floor(Math.random() * 20) + 50
                    }))
                };
                
                mockData.winRate = mockData.wins / (mockData.wins + mockData.losses);
                mockData.avgScoreDiff = mockData.recentScores.reduce((sum, game) => 
                    sum + (game.score - game.opponentScore), 0) / mockData.recentScores.length;
                
                AIAnalytics.historicalData[teamId] = mockData;
                return mockData;
            } catch (e) {
                Logger.warning(`获取队伍 ${teamName} 历史数据失败: ${e.message}`, true);
                return null;
            }
        }

        // 预测获胜者
        function predictWinner(teamDataArray, teamNames, betItem) {
            const validData = teamDataArray.filter(data => data !== null);
            if (validData.length < 2) {
                const highestOddsOption = getHighestOddsOption(betItem);
                return {
                    prediction: highestOddsOption ? highestOddsOption.text : teamNames[0],
                    confidence: 0.5
                };
            }
            
            const teamScores = validData.map(data => {
                const winRateScore = data.winRate * 0.4;
                const recentFormScore = Math.min(1, Math.max(0, (data.avgScoreDiff + 10) / 20)) * 0.3;
                const option = betItem.optionsList.find(opt => opt.text.includes(data.teamName));
                const odds = option ? parseFloat(option.odds) : 1;
                const oddsScore = Math.min(1, 2 / odds) * 0.3;
                
                return {
                    teamName: data.teamName,
                    score: winRateScore + recentFormScore + oddsScore
                };
            });
            
            const maxScore = Math.max(...teamScores.map(ts => ts.score));
            const prediction = teamScores.find(ts => ts.score === maxScore).teamName;
            const sortedScores = [...teamScores.map(ts => ts.score)].sort((a, b) => b - a);
            const confidence = Math.min(1, 0.5 + (sortedScores[0] - sortedScores[1]) * 2);
            
            return { prediction, confidence };
        }

        // 策略分析逻辑
        function shouldPlaceBet(item) {
            if (!item.optionsList || item.optionsList.length === 0) {
                Logger.warning(`项目 #${item.id} 没有可选项，不参与投注`, true);
                return false;
            }
            
            switch (CONFIG.state.betStrategy) {
                case "larger":
                    const isLargerEligible = item.optionsList.length <= 3;
                    Logger.debug(`项目 #${item.id} 押大策略检查: ${isLargerEligible ? '通过' : '不通过'} (选项数量: ${item.optionsList.length})`);
                    return isLargerEligible;
                case "smaller":
                    const isSmallerEligible = item.optionsList.length <= 3;
                    Logger.debug(`项目 #${item.id} 押小策略检查: ${isSmallerEligible ? '通过' : '不通过'} (选项数量: ${item.optionsList.length})`);
                    return isSmallerEligible;
                case "follow":
                    Logger.debug(`项目 #${item.id} 跟随策略检查: 通过`);
                    return true;
                case "higher_odds":
                    const highestOption = getHighestOddsOption(item);
                    const meetsThreshold = !!highestOption;
                    Logger.debug(`项目 #${item.id} 高赔率策略检查: ${meetsThreshold ? '通过' : '不通过'} (最高赔率: ${highestOption?.odds || 'N/A'})`);
                    return meetsThreshold;
                default:
                    return false;
            }
        }

        // 计算投注金额
        function calculateBetAmount() {
            if (CONFIG.state.amountRange <= 0) return CONFIG.state.baseAmount;
            const randomOffset = Math.floor(Math.random() * (CONFIG.state.amountRange * 2 + 1)) - CONFIG.state.amountRange;
            return Math.max(CONFIG.state.baseAmount + randomOffset, 100);
        }

        // 执行投注操作（修复服务停止时投注中断问题）
        async function placeBet(betItem) {
            updateLastActivity();
            AppState.setBettingInProgress(true);
            try {
                Logger.info(`开始为项目 #${betItem.id} 下注，策略: ${CONFIG.state.betStrategy}, 金额: ${betItem.betAmount}`);
                
                let choices = [];
                let myBonuses = [];
                let currentOdds = 0;

                if (CONFIG.state.betStrategy === "higher_odds") {
                    const freshBetItem = CONFIG.state.availableBets.find(item => item.id === betItem.id);
                    if (!freshBetItem) {
                        Logger.error(`项目 #${betItem.id} 已失效，取消投注`);
                        AppState.setBettingInProgress(false);
                        return false;
                    }
                    
                    const aiPrediction = AIAnalytics.predictionCache[betItem.id];
                    let selectedOption;
                    
                    if (aiPrediction && CONFIG.state.aiPredictionEnabled) {
                        selectedOption = freshBetItem.optionsList.find(opt => 
                            opt.text.includes(aiPrediction.prediction)
                        );
                        Logger.debug(`使用AI预测结果投注: ${aiPrediction.prediction} (可信度: ${(aiPrediction.confidence * 100).toFixed(1)}%)`);
                    }
                    
                    if (!selectedOption) {
                        selectedOption = getHighestOddsOption(freshBetItem);
                    }
                    
                    if (!selectedOption) {
                        Logger.error(`项目 #${betItem.id} 没有找到有效选项`);
                        AppState.setBettingInProgress(false);
                        return false;
                    }
                    
                    currentOdds = parseFloat(selectedOption.odds);
                    choices = [selectedOption.id];
                    myBonuses = [calculateBetAmount()];
                    Logger.debug(`投注: 选项 ${selectedOption.text} (赔率: ${selectedOption.odds}), 金额 ${myBonuses[0]}`);
                }
                else if (CONFIG.state.betStrategy === "larger") {
                    choices = await getLargerOptions(betItem.id);
                    if (choices.length === 0) {
                        Logger.error(`项目 #${betItem.id} 没有符合押大策略的选项`);
                        AppState.setBettingInProgress(false);
                        return false;
                    }
                    
                    choices.forEach(() => {
                        myBonuses.push(calculateBetAmount());
                    });
                } 
                else if (CONFIG.state.betStrategy === "smaller") {
                    choices = await getSmallerOptions(betItem.id);
                    if (choices.length === 0) {
                        Logger.error(`项目 #${betItem.id} 没有符合押小策略的选项`);
                        AppState.setBettingInProgress(false);
                        return false;
                    }
                    
                    choices.forEach(() => {
                        myBonuses.push(calculateBetAmount());
                    });
                }
                
                for (let i = 0; i < choices.length; i++) {
                    // 新增服务状态检查，服务停止时终止投注
                    if (!AppState.getServiceRunning()) {
                        Logger.error(`服务已停止，终止项目 #${betItem.id} 投注流程`);
                        AppState.setBettingInProgress(false);
                        return false;
                    }
                    
                    const optId = choices[i];
                    const bonus = myBonuses[i];
                    
                    if (GlobalInfo.bet_mask[betItem.id]?.includes(optId)) {
                        Logger.debug(`选项 ${optId} 已投注，跳过`);
                        continue;
                    }
                    
                    const url = `${CONFIG.mainHost}/${CONFIG.apis.betgameOdds
                        .replace('{optId}', optId)
                        .replace('{bonus}', bonus)}`;
                    
                    // 实时更新投注状态
                    const betIndex = AppState.pendingBets.findIndex(b => b.id === betItem.id && b.status === "等待中");
                    if (betIndex !== -1) {
                        AppState.pendingBets[betIndex].status = "处理中";
                        renderPendingBetsTable();
                    }
                    
                    const result = await request(url);
                    
                    if (result.code !== 0) {
                        Logger.error(`项目 #${betItem.id} 选项 ${optId} 投注失败: ${result.msg || '未知错误'}`);
                        // 恢复状态
                        if (betIndex !== -1) {
                            AppState.pendingBets[betIndex].status = "失败";
                            renderPendingBetsTable();
                        }
                        AppState.setBettingInProgress(false);
                        return false;
                    }
                    
                    Logger.info(`项目 #${betItem.id} 选项 ${optId} 下注成功: ${result.msg || '操作成功'}`);
                    
                    if (!GlobalInfo.bet_mask[betItem.id]) {
                        GlobalInfo.bet_mask[betItem.id] = [];
                    }
                    GlobalInfo.bet_mask[betItem.id].push(optId);
                    
                    // 实时更新为已完成
                    if (betIndex !== -1) {
                        AppState.pendingBets[betIndex].status = "已完成";
                        renderPendingBetsTable();
                    }
                    
                    if (i < choices.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, CONFIG.state.checkInterval * 1000));
                    }
                }
                
                Logger.info(`项目 #${betItem.id} 下注成功`);
                AudioPlayer.playBetSuccess();
                Logger.info(`投注成功，3秒后自动刷新可投注项目...`);
                setTimeout(() => loadBetItems(), 3000);
                
                const serviceStopHandler = () => {
                    if (AppState.getServiceRunning()) {
                        Logger.info("投注完成后延迟1分钟，停止服务");
                        stopService();
                        
                        setTimeout(() => {
                            Logger.info("停止服务后延迟10秒，重启5分钟自动检测机制");
                            startFiveMinCheckTimer();
                            AppState.setBettingInProgress(false);
                        }, 10000);
                    } else {
                        Logger.info("服务已停止，无需重复操作");
                        AppState.setBettingInProgress(false);
                    }
                };
                
                const stopTimer = setTimeout(serviceStopHandler, 60000);
                window.serviceStopTimer = stopTimer;
                
                return true;
            } catch (e) {
                Logger.warning("主服务器下注失败，尝试备用服务器...");
                try {
                    for (let i = 0; i < choices.length; i++) {
                        // 新增服务状态检查
                        if (!AppState.getServiceRunning()) {
                            Logger.error(`服务已停止，终止项目 #${betItem.id} 投注流程`);
                            AppState.setBettingInProgress(false);
                            return false;
                        }
                        
                        const optId = choices[i];
                        const bonus = myBonuses[i];
                        
                        if (GlobalInfo.bet_mask[betItem.id]?.includes(optId)) {
                            continue;
                        }
                        
                        const url = `${CONFIG.testHost}/${CONFIG.apis.betgameOdds
                            .replace('{optId}', optId)
                            .replace('{bonus}', bonus)}`;
                        
                        const betIndex = AppState.pendingBets.findIndex(b => b.id === betItem.id && b.status === "等待中");
                        if (betIndex !== -1) {
                            AppState.pendingBets[betIndex].status = "处理中";
                            renderPendingBetsTable();
                        }
                        
                        const result = await request(url);
                        
                        if (result.code !== 0) {
                            Logger.error(`备用服务器 - 项目 #${betItem.id} 选项 ${optId} 投注失败: ${result.msg || '未知错误'}`);
                            if (betIndex !== -1) {
                                AppState.pendingBets[betIndex].status = "失败";
                                renderPendingBetsTable();
                            }
                            AppState.setBettingInProgress(false);
                            return false;
                        }
                        
                        Logger.info(`备用服务器 - 项目 #${betItem.id} 选项 ${optId} 下注成功: ${result.msg || '操作成功'}`);
                        
                        if (!GlobalInfo.bet_mask[betItem.id]) {
                            GlobalInfo.bet_mask[betItem.id] = [];
                        }
                        GlobalInfo.bet_mask[betItem.id].push(optId);
                        
                        if (betIndex !== -1) {
                            AppState.pendingBets[betIndex].status = "已完成";
                            renderPendingBetsTable();
                        }
                        
                        if (i < choices.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, CONFIG.state.checkInterval * 1000));
                        }
                    }
                    
                    Logger.info(`备用服务器 - 项目 #${betItem.id} 下注成功`);
                    AudioPlayer.playBetSuccess();
                    Logger.info(`投注成功，3秒后自动刷新可投注项目...`);
                    setTimeout(() => loadBetItems(), 3000);
                    
                    const serviceStopHandler = () => {
                        if (AppState.getServiceRunning()) {
                            Logger.info("投注完成后延迟1分钟，停止服务");
                            stopService();
                            
                            setTimeout(() => {
                                Logger.info("停止服务后延迟10秒，重启5分钟自动检测机制");
                                startFiveMinCheckTimer();
                                AppState.setBettingInProgress(false);
                            }, 10000);
                        } else {
                            Logger.info("服务已停止，无需重复操作");
                            AppState.setBettingInProgress(false);
                        }
                    };
                    
                    const stopTimer = setTimeout(serviceStopHandler, 60000);
                    window.serviceStopTimer = stopTimer;
                    
                    return true;
                } catch (e2) {
                    Logger.error(`项目 #${betItem.id} 下注请求失败: ${e2.message}`);
                    AppState.setBettingInProgress(false);
                    return false;
                }
            }
        }

        // 检查并执行待下注项目
        function checkAndPlaceBets() {
            if (!AppState.getServiceRunning() || AppState.getBettingInProgress()) return;
            
            updateLastActivity();
            const now = new Date();
            Logger.debug("正在检查待下注项目...");
            
            AppState.pendingBets.forEach(bet => {
                if (bet.strategy === "follow") return;
                
                if (now >= bet.betTime && bet.status === "等待中") {
                    bet.status = "处理中";
                    renderPendingBetsTable();
                    
                    (async () => {
                        const success = await placeBet(bet);
                        bet.status = success ? "已完成" : "失败";
                        renderPendingBetsTable();
                    })();
                }
            });
            
            if (AppState.getServiceRunning() && !AppState.getBettingInProgress()) {
                AppState.betCheckTimer = setTimeout(checkAndPlaceBets, CONFIG.state.checkInterval * 1000);
            }
        }

        // 5分钟自动检测机制（修复重复启动问题）
        function startFiveMinCheckTimer() {
            // 启动前先停止旧定时器，确保单例
            stopFiveMinCheckTimer();
            
            Logger.info("启动5分钟自动检测机制（每5分钟检测可投注/待投注项目）");
            
            fiveMinCheckHandler();
            
            AppState.fiveMinCheckTimer = setInterval(fiveMinCheckHandler, FIVE_MINUTES);
        }

        function stopFiveMinCheckTimer() {
            if (AppState.fiveMinCheckTimer) {
                clearInterval(AppState.fiveMinCheckTimer);
                AppState.fiveMinCheckTimer = null;
                Logger.info("已停止5分钟自动检测机制");
            }
        }

        // 5分钟检测处理函数
        async function fiveMinCheckHandler() {
            if (AppState.getBettingInProgress()) return;
            
            Logger.info("执行5分钟自动检测：检查可投注项目和待投注项目");
            
            await loadBetItems();
            
            const now = new Date();
            const urgentBets = AppState.pendingBets.filter(bet => {
                if (bet.status !== "等待中") return false;
                const timeDiff = bet.betTime - now;
                return timeDiff > 0 && timeDiff <= BET_WARN_TIME;
            });
            
            if (urgentBets.length > 0) {
                Logger.info(`检测到 ${urgentBets.length} 个待投注项目距离下注时间不足10分钟，自动启动服务并停止5分钟检测`);
                
                stopFiveMinCheckTimer();
                
                Logger.info("检测到紧急项目，保留数据刷新倒计时");
                
                AppState.isServiceStartedByCheck = true;
                
                if (!AppState.getServiceRunning()) {
                    await startService(true);
                }
                
                startBetChecker();
            } else {
                Logger.info("未检测到紧急待投注项目，继续保持5分钟检测");
            }
        }

        // 日志弹窗控制
        function toggleLogModal() {
            AppState.logModalVisible = !AppState.logModalVisible;
            const modal = document.getElementById('logModal');
            if (modal) {
                modal.classList.toggle('hidden', !AppState.logModalVisible);
                Logger.render();
            }
        }

        // 更新最后活动时间
        function updateLastActivity() {
            AppState.lastActivityTime = new Date().getTime();
        }

        // 服务控制函数
        async function startService(isFromCheck = false) {
            if (AppState.getServiceRunning()) {
                Logger.warning("服务已在运行中");
                return;
            }
            
            Logger.info("开始验证API Key并准备启动服务...");
            const apiValid = await verifyApiKey();
            if (!apiValid) {
                Logger.error("API Key验证失败，无法启动服务");
                return;
            }
            
            AppState.isServiceStartedByCheck = isFromCheck; 
            saveParameters();
            
            if (!isFromCheck) {
                startAutoRefresh();
                startFiveMinCheckTimer();
            }
            
            startBetChecker();
            resetRefreshCycle();
            
            AppState.isPageVisible = true;
            document.addEventListener('visibilitychange', handleVisibilityChange);
            
            AppState.setServiceRunning(true);
            Logger.info(isFromCheck 
                ? "服务已由5分钟检测机制自动启动" 
                : "服务已手动启动");
        }

        // 停止服务（优化定时器清理）
        function stopService() {
            if (!AppState.getServiceRunning()) {
                Logger.warning("服务未在运行中");
                return;
            }
            
            // 清理所有跟随定时器
            AppState.clearFollowTimers();
            
            if (!AppState.isServiceStartedByCheck) {
                stopAutoRefresh();
            }
            
            stopBetChecker();
            stopRefreshCountdown();
            document.removeEventListener('visibilitychange', handleVisibilityChange);
            
            AppState.isServiceStartedByCheck = false;
            AppState.setServiceRunning(false);
            Logger.info("服务已停止");
        }

        // 自动刷新控制
        function startAutoRefresh() {
            stopAutoRefresh();
            
            const refresh = () => {
                if (CONFIG.state.autoRefresh && AppState.getServiceRunning()) {
                    const now = new Date().getTime();
                    const timeSinceLast = now - AppState.lastActivityTime;
                    
                    if (AppState.isPageVisible || timeSinceLast > 3 * 60 * 1000) {
                        Logger.debug(`执行数据刷新（间隔: ${CONFIG.state.refreshInterval}秒）`);
                        loadBetItems();
                    } else {
                        Logger.debug(`页面在后台，延迟数据刷新`);
                        scheduleNextRefresh();
                    }
                }
                
                if (AppState.getServiceRunning() && CONFIG.state.autoRefresh) {
                    scheduleNextRefresh();
                }
            };
            
            refresh();
        }

        // 精确计算并安排下一次刷新
        function scheduleNextRefresh() {
            const now = Date.now();
            const intervalMs = CONFIG.state.refreshInterval * 1000;
            
            const nextRefreshTime = AppState.refreshCycleStartTime + intervalMs;
            const delay = Math.max(0, nextRefreshTime - now);
            
            AppState.autoRefreshTimer = setTimeout(() => {
                if (AppState.getServiceRunning() && CONFIG.state.autoRefresh) {
                    loadBetItems();
                }
            }, delay);
            
            Logger.debug(`下一次数据刷新时间: ${new Date(nextRefreshTime).toLocaleTimeString({
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                fractionalSecondDigits: 3
            })}`);
        }

        function stopAutoRefresh() {
            if (AppState.autoRefreshTimer) {
                clearTimeout(AppState.autoRefreshTimer);
                AppState.autoRefreshTimer = null;
            }
        }

        // 投注检查器
        function startBetChecker() {
            stopBetChecker();
            checkAndPlaceBets();
        }

        function stopBetChecker() {
            if (AppState.betCheckTimer) {
                clearTimeout(AppState.betCheckTimer);
                AppState.betCheckTimer = null;
            }
        }

        // 处理页面可见性变化
        function handleVisibilityChange() {
            const wasVisible = AppState.isPageVisible;
            AppState.isPageVisible = document.visibilityState === 'visible';
            
            if (AppState.isPageVisible && !wasVisible && AppState.getServiceRunning()) {
                Logger.info("页面恢复可见，同步倒计时状态...", true);
                
                startRefreshCountdown();
                
                const now = Date.now();
                const timeDiff = now - AppState.lastActivityTime;
                if (timeDiff > 60000) {
                    Logger.info(`页面在后台停留了 ${Math.floor(timeDiff/1000)} 秒，强制刷新数据`);
                    loadBetItems();
                } else {
                    scheduleNextRefresh();
                }
                
                if (!AppState.betCheckTimer) {
                    startBetChecker();
                }
            } else if (!AppState.isPageVisible && wasVisible && AppState.getServiceRunning()) {
                Logger.info("页面进入后台，暂停倒计时显示...", true);
                stopRefreshCountdown();
            }
        }

        // 重置刷新周期开始时间
        function resetRefreshCycle() {
            AppState.refreshCycleStartTime = Date.now();
            if (AppState.getServiceRunning() && CONFIG.state.autoRefresh) {
                startRefreshCountdown();
                scheduleNextRefresh();
            } else {
                const hmsms = convertMsToHMSMs(CONFIG.state.refreshInterval * 1000);
                document.getElementById("refreshIntervalDisplay").textContent = 
                    `${hmsms.hours.toString().padStart(2, '0')}:${hmsms.minutes.toString().padStart(2, '0')}:${hmsms.seconds.toString().padStart(2, '0')}.${hmsms.milliseconds.toString().padStart(3, '0')}`;
            }
        }

        // 转换总毫秒数为小时、分、秒、毫秒
        function convertMsToHMSMs(totalMs) {
            const hours = Math.floor(totalMs / 3600000);
            const minutes = Math.floor((totalMs % 3600000) / 60000);
            const seconds = Math.floor((totalMs % 60000) / 1000);
            const milliseconds = Math.floor(totalMs % 1000);
            return { hours, minutes, seconds, milliseconds };
        }

        // 格式化倒计时（含毫秒）
        function formatCountdownWithMs(ms) {
            const h = Math.floor(ms / 3600000).toString().padStart(2, '0');
            const m = Math.floor((ms % 3600000) / 60000).toString().padStart(2, '0');
            const s = Math.floor((ms % 60000) / 1000).toString().padStart(2, '0');
            const msStr = Math.floor(ms % 1000).toString().padStart(3, '0');
            return h === '00' ? `${m}:${s}.${msStr}` : `${h}:${m}:${s}.${msStr}`;
        }

        // 刷新间隔倒计时控制（支持毫秒）
        function startRefreshCountdown() {
            stopRefreshCountdown();
            
            const updateDisplay = () => {
                const now = Date.now();
                const intervalMs = CONFIG.state.refreshInterval * 1000;
                const elapsedMs = now - AppState.refreshCycleStartTime;
                const remainingMs = Math.max(0, intervalMs - elapsedMs);
                
                document.getElementById("refreshIntervalDisplay").textContent = formatCountdownWithMs(remainingMs);
            };
            
            updateDisplay();
            const animate = () => {
                if (AppState.countdownTimer) {
                    updateDisplay();
                    AppState.countdownTimer = requestAnimationFrame(animate);
                }
            };
            
            AppState.countdownTimer = requestAnimationFrame(animate);
        }

        function stopRefreshCountdown() {
            if (AppState.countdownTimer) {
                cancelAnimationFrame(AppState.countdownTimer);
                AppState.countdownTimer = null;
            }
        }

        // 其他辅助函数
        function toggleAutoRefresh() {
            CONFIG.state.autoRefresh = !CONFIG.state.autoRefresh;
            document.getElementById("autoRefreshBtn").textContent = CONFIG.state.autoRefresh ? "关闭自动刷新" : "开启自动刷新";
            Logger.info(`自动刷新已${CONFIG.state.autoRefresh ? '开启' : '关闭'}`);
            
            if (AppState.getServiceRunning()) {
                if (CONFIG.state.autoRefresh) {
                    resetRefreshCycle();
                } else {
                    stopAutoRefresh();
                    stopRefreshCountdown();
                    const hmsms = convertMsToHMSMs(CONFIG.state.refreshInterval * 1000);
                    document.getElementById("refreshIntervalDisplay").textContent = 
                        `${hmsms.hours.toString().padStart(2, '0')}:${hmsms.minutes.toString().padStart(2, '0')}:${hmsms.seconds.toString().padStart(2, '0')}.${hmsms.milliseconds.toString().padStart(3, '0')}`;
                }
            }
        }

        // 转换小时、分、秒为总秒数
        function convertToSeconds(hours, minutes, seconds) {
            return (hours * 3600) + (minutes * 60) + seconds;
        }

        // 转换总秒数为小时、分、秒
        function convertToHMS(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return { hours, minutes, seconds };
        }

        // 设置刷新间隔（适配毫秒显示）
        function setRefreshInterval() {
            const hours = parseInt(document.getElementById("refreshHoursInput").value) || 0;
            const minutes = parseInt(document.getElementById("refreshMinutesInput").value) || 0;
            const seconds = parseInt(document.getElementById("refreshSecondsInput").value) || 0;
            
            const totalSeconds = convertToSeconds(hours, minutes, seconds);
            
            if (totalSeconds >= 5 && totalSeconds <= 86400) {
                const oldInterval = CONFIG.state.refreshInterval;
                CONFIG.state.refreshInterval = totalSeconds;
                
                const hmsms = convertMsToHMSMs(totalSeconds * 1000);
                Logger.info(`已设置数据刷新间隔为 ${hours}小时${minutes}分${seconds}秒${hmsms.milliseconds}毫秒 (${totalSeconds}秒)`);
                
                if (oldInterval !== totalSeconds && AppState.getServiceRunning()) {
                    Logger.info("刷新间隔已更改，从当前时间开始新周期", true);
                    resetRefreshCycle();
                } else if (!AppState.getServiceRunning()) {
                    document.getElementById("refreshIntervalDisplay").textContent = 
                        `${hmsms.hours.toString().padStart(2, '0')}:${hmsms.minutes.toString().padStart(2, '0')}:${hmsms.seconds.toString().padStart(2, '0')}.${hmsms.milliseconds.toString().padStart(3, '0')}`;
                }
            } else {
                Logger.warning("无效的刷新间隔值（必须为5秒-86400秒之间）");
                const hms = convertToHMS(CONFIG.state.refreshInterval);
                document.getElementById("refreshHoursInput").value = hms.hours;
                document.getElementById("refreshMinutesInput").value = hms.minutes;
                document.getElementById("refreshSecondsInput").value = hms.seconds;
            }
        }

        // 手动修改待下注项目时间的功能
        function editPendingBetTime(betId) {
            const bet = AppState.pendingBets.find(b => b.id === betId);
            if (!bet) return;
            
            const currentTime = bet.betTime.toISOString().slice(0, 16);
            const newTimeStr = prompt("修改下注时间:", currentTime);
            
            if (newTimeStr) {
                try {
                    const newTime = new Date(newTimeStr);
                    if (!isNaN(newTime.getTime())) {
                        bet.betTime = newTime;
                        Logger.info(`已修改项目 #${betId} 的下注时间为: ${newTime.toLocaleString()}`);
                        renderPendingBetsTable();
                        renderBetTable();
                    } else {
                        Logger.warning("无效的时间格式");
                    }
                } catch (e) {
                    Logger.error(`修改时间失败: ${e.message}`);
                }
            }
        }

        function manualRefresh() {
            loadBetItems();
        }

        // 保存参数
        function saveParameters() {
            try {
                const oldRefreshInterval = CONFIG.state.refreshInterval;
                
                CONFIG.state.targetUserId = document.getElementById("targetUserIdInput").value || "205809";
                CONFIG.state.advanceSeconds = Math.max(0, parseInt(document.getElementById("advanceSecondsInput").value) || 3);
                CONFIG.state.amountRange = Math.max(0, parseInt(document.getElementById("amountRangeInput").value) || 100);
                CONFIG.state.baseAmount = Math.max(100, parseInt(document.getElementById("baseAmountInput").value) || 1000);
                CONFIG.state.betStrategy = document.getElementById("betStrategySelect").value || "higher_odds";
                CONFIG.state.checkInterval = Math.max(0.1, parseFloat(document.getElementById("checkIntervalInput").value) || 2);
                CONFIG.state.detailedLogMode = document.getElementById("detailedLogModeCheckbox").checked;
                CONFIG.state.pendingFilter = document.getElementById("pendingFilterSelect").value || "all";
                CONFIG.state.followCheckInterval = Math.max(100, parseInt(document.getElementById("followCheckIntervalInput").value) || 500);
                CONFIG.state.aiPredictionEnabled = document.getElementById("aiPredictionEnabledCheckbox").checked;
                
                const newScheduleEnabled = document.getElementById("scheduleEnabledCheckbox").checked;
                CONFIG.state.scheduleEnabled = newScheduleEnabled;
                CONFIG.state.scheduleStartTime = document.getElementById("scheduleStartTimeInput").value || "09:00";
                CONFIG.state.scheduleStopTime = document.getElementById("scheduleStopTimeInput").value || "23:00";
                
                const hours = parseInt(document.getElementById("refreshHoursInput").value) || 0;
                const minutes = parseInt(document.getElementById("refreshMinutesInput").value) || 0;
                const seconds = parseInt(document.getElementById("refreshSecondsInput").value) || 0;
                const totalSeconds = convertToSeconds(hours, minutes, seconds);
                if (totalSeconds >= 5 && totalSeconds <= 86400) {
                    CONFIG.state.refreshInterval = totalSeconds;
                }
                
                document.getElementById("advanceSecondsInput").value = CONFIG.state.advanceSeconds;
                document.getElementById("amountRangeInput").value = CONFIG.state.amountRange;
                document.getElementById("baseAmountInput").value = CONFIG.state.baseAmount;
                document.getElementById("checkIntervalInput").value = CONFIG.state.checkInterval;
                document.getElementById("followCheckIntervalInput").value = CONFIG.state.followCheckInterval;
                
                Logger.toggleDetailedMode(CONFIG.state.detailedLogMode);
                const hms = convertToHMS(CONFIG.state.refreshInterval);
                Logger.info(`参数配置已保存 - 提前下注: ${CONFIG.state.advanceSeconds}s, 刷新间隔: ${hms.hours}小时${hms.minutes}分${hms.seconds}秒, 检查间隔: ${CONFIG.state.checkInterval}s`);
                
                if (newScheduleEnabled) {
                    setupSchedule();
                } else {
                    clearSchedule();
                }
                
                if (AppState.getServiceRunning()) {
                    flushConfig().then(() => {
                        processPendingBets(true);
                        renderBetTable();
                        renderPendingBetsTable();
                        
                        startBetChecker();
						                        if (oldRefreshInterval !== CONFIG.state.refreshInterval) {
                            Logger.info("刷新间隔已更新，重新启动自动刷新");
                            resetRefreshCycle();
                        }
                    });
                } else {
                    const hmsms = convertMsToHMSMs(CONFIG.state.refreshInterval * 1000);
                    document.getElementById("refreshIntervalDisplay").textContent = 
                        `${hmsms.hours.toString().padStart(2, '0')}:${hmsms.minutes.toString().padStart(2, '0')}:${hmsms.seconds.toString().padStart(2, '0')}.${hmsms.milliseconds.toString().padStart(3, '0')}`;
                }
            } catch (e) {
                Logger.error(`保存参数失败: ${e.message}`);
            }
        }

        // 定时任务设置（保持原有跨天判断逻辑不变）
        function setupSchedule() {
            clearSchedule();
            
            const [startHours, startMinutes] = CONFIG.state.scheduleStartTime.split(':').map(Number);
            const [stopHours, stopMinutes] = CONFIG.state.scheduleStopTime.split(':').map(Number);
            
            Logger.info(`已设置定时任务 - 启动时间: ${CONFIG.state.scheduleStartTime}, 停止时间: ${CONFIG.state.scheduleStopTime}`);
            
            const checkSchedule = () => {
                const now = new Date();
                const currentHours = now.getHours();
                const currentMinutes = now.getMinutes();
                const currentTimeInMinutes = currentHours * 60 + currentMinutes;
                const startTimeInMinutes = startHours * 60 + startMinutes;
                const stopTimeInMinutes = stopHours * 60 + stopMinutes;
                
                let shouldBeRunning = false;
                
                // 保持原有跨天判断逻辑不变
                if (startTimeInMinutes <= stopTimeInMinutes) {
                    shouldBeRunning = currentTimeInMinutes >= startTimeInMinutes && currentTimeInMinutes < stopTimeInMinutes;
                } else {
                    shouldBeRunning = currentTimeInMinutes >= startTimeInMinutes || currentTimeInMinutes < stopTimeInMinutes;
                }
                
                if (shouldBeRunning && !AppState.getServiceRunning()) {
                    Logger.info(`定时任务触发: 启动服务 (当前时间: ${currentHours}:${currentMinutes.toString().padStart(2, '0')})`);
                    startService().then(() => {
                        AudioPlayer.playScheduleStart();
                    });
                } else if (!shouldBeRunning && AppState.getServiceRunning()) {
                    Logger.info(`定时任务触发: 停止服务 (当前时间: ${currentHours}:${currentMinutes.toString().padStart(2, '0')})`);
                    stopService();
                    AudioPlayer.playScheduleStop();
                }
                
                AppState.scheduleTimers.check = setTimeout(checkSchedule, 60000);
            };
            
            checkSchedule();
        }

        function clearSchedule() {
            if (AppState.scheduleTimers.check) {
                clearTimeout(AppState.scheduleTimers.check);
                AppState.scheduleTimers.check = null;
                Logger.info("已清除定时任务");
            }
        }

        // 渲染投注项目表格
        function renderBetTable() {
            const tableBody = document.getElementById("betTableBody");
            if (!tableBody) return;
            
            tableBody.innerHTML = "";
            
            if (CONFIG.state.availableBets.length === 0) {
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="8" class="text-center py-4 text-gray-500">
                            <i class="fa fa-info-circle mr-2"></i>暂无可用投注项目
                        </td>
                    </tr>
                `;
                return;
            }
            
            CONFIG.state.availableBets.forEach((bet, index) => {
                const tr = document.createElement("tr");
                tr.className = "border-b hover:bg-gray-50 table-hover-row transition-colors";
                
                const isFollowed = GlobalInfo.followedBets[bet.id];
                const highestOddsOption = getHighestOddsOption(bet);
                const highestOdds = highestOddsOption ? parseFloat(highestOddsOption.odds) : 0;
                
                const aiPrediction = AIAnalytics.predictionCache[bet.id];
                const predictionText = aiPrediction ? 
                    `${aiPrediction.prediction} (${(aiPrediction.confidence * 100).toFixed(1)}%)` : 
                    "分析中...";
                
                tr.innerHTML = `
                    <td class="py-3 px-4">${index + 1}</td>
                    <td class="py-3 px-4 max-w-xs truncate">${bet.heading}</td>
                    <td class="py-3 px-4 text-sm">${bet.undertext || '-'}</td>
                    <td class="py-3 px-4 text-sm">
                        ${bet.optionsList.map(opt => {
                            const isHighest = highestOddsOption && opt.id === highestOddsOption.id;
                            return `<div class="${isHighest ? 'odds-highlight' : ''}">
                                ${opt.text}: <strong>${opt.odds}</strong>
                            </div>`;
                        }).join('')}
                    </td>
                    <td class="py-3 px-4 text-sm">
                        ${new Date(bet.endtime).toLocaleString('zh-CN', {
                            month: '2-digit',
                            day: '2-digit',
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit'
                        })}
                    </td>
                    <td class="py-3 px-4 text-sm ${CONFIG.state.aiPredictionEnabled ? '' : 'text-gray-400'}">
                        ${CONFIG.state.aiPredictionEnabled ? predictionText : '已禁用'}
                    </td>
                    <td class="py-3 px-4">
                        ${isFollowed ? 
                            `<span class="bg-green-100 text-green-800 text-xs px-2 py-1 rounded-full">
                                已跟随
                            </span>` : 
                            `<button onclick="startFollowingCheck('${bet.id}')" 
                                class="bg-purple-100 hover:bg-purple-200 text-purple-800 text-xs px-2 py-1 rounded-full transition-colors"
                                ${!AppState.getServiceRunning() ? 'disabled title="请先启动服务"' : ''}>
                                开始跟随
                            </button>`
                        }
                    </td>
                    <td class="py-3 px-4">
                        <button onclick="addToPending('${bet.id}')" 
                            class="bg-primary/10 hover:bg-primary/20 text-primary text-xs px-2 py-1 rounded-full transition-colors"
                            ${!AppState.getServiceRunning() ? 'disabled title="请先启动服务"' : ''}>
                            加入待投
                        </button>
                    </td>
                `;
                
                tableBody.appendChild(tr);
            });
        }

        // 添加到待投注列表
        function addToPending(betId) {
            const betItem = CONFIG.state.availableBets.find(item => item.id === betId);
            if (!betItem) {
                Logger.warning(`项目 #${betId} 不存在或已失效`);
                return;
            }
            
            const existingIndex = AppState.pendingBets.findIndex(bet => bet.id === betId);
            if (existingIndex !== -1) {
                Logger.warning(`项目 #${betId} 已在待投注列表中`);
                return;
            }
            
            const cfg = GlobalInfo.configs[betId];
            if (!cfg) {
                Logger.warning(`项目 #${betId} 配置不存在`);
                return;
            }
            
            const highestOddsOption = getHighestOddsOption(betItem);
            const betAmount = calculateBetAmount();
            const odds = highestOddsOption ? parseFloat(highestOddsOption.odds) : 0;
            
            const newBet = {
                ...betItem,
                id: betId,
                betTime: cfg.scheduled_time,
                betAmount,
                strategy: CONFIG.state.betStrategy,
                status: "等待中",
                highestOdds: odds,
                highestOddsTeam: highestOddsOption ? highestOddsOption.text : 'N/A',
                ratioValue: odds * betAmount,
                recordedOdds: odds
            };
            
            AppState.pendingBets.push(newBet);
            AppState.pendingBets.sort((a, b) => a.betTime - b.betTime);
            
            Logger.info(`已将项目 #${betId} 添加到待投注列表，预计投注时间: ${new Date(cfg.scheduled_time).toLocaleString()}`);
            renderPendingBetsTable();
        }

        // 渲染待投注项目表格
        function renderPendingBetsTable() {
            const tableBody = document.getElementById("pendingBetsTableBody");
            if (!tableBody) return;
            
            tableBody.innerHTML = "";
            
            if (AppState.pendingBets.length === 0) {
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="7" class="text-center py-4 text-gray-500">
                            <i class="fa fa-clock-o mr-2"></i>暂无待投注项目
                        </td>
                    </tr>
                `;
                return;
            }
            
            AppState.pendingBets.forEach((bet, index) => {
                const tr = document.createElement("tr");
                tr.className = `border-b transition-colors ${
                    bet.status === "处理中" ? "bg-blue-50" : 
                    bet.status === "已完成" ? "bg-green-50" : 
                    bet.status === "失败" ? "bg-red-50" : "hover:bg-gray-50"
                }`;
                
                let statusBadge = "";
                switch (bet.status) {
                    case "等待中":
                        statusBadge = `<span class="bg-yellow-100 text-yellow-800 text-xs px-2 py-1 rounded-full">等待中</span>`;
                        break;
                    case "处理中":
                        statusBadge = `<span class="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded-full">处理中</span>`;
                        break;
                    case "已完成":
                        statusBadge = `<span class="bg-green-100 text-green-800 text-xs px-2 py-1 rounded-full">已完成</span>`;
                        break;
                    case "失败":
                        statusBadge = `<span class="bg-red-100 text-red-800 text-xs px-2 py-1 rounded-full">失败</span>`;
                        break;
                }
                
                const now = new Date();
                const timeDiff = bet.betTime - now;
                let timeDiffText = "";
                
                if (timeDiff > 0) {
                    const hours = Math.floor(timeDiff / 3600000);
                    const minutes = Math.floor((timeDiff % 3600000) / 60000);
                    const seconds = Math.floor((timeDiff % 60000) / 1000);
                    
                    if (hours > 0) {
                        timeDiffText = `${hours}时${minutes}分后`;
                    } else if (minutes > 0) {
                        timeDiffText = `${minutes}分${seconds}秒后`;
                    } else {
                        timeDiffText = `${seconds}秒后`;
                    }
                } else {
                    timeDiffText = "已过期";
                }
                
                tr.innerHTML = `
                    <td class="py-3 px-4">${index + 1}</td>
                    <td class="py-3 px-4 max-w-xs truncate">${bet.heading}</td>
                    <td class="py-3 px-4 text-sm">
                        ${bet.highestOddsTeam} (${bet.highestOdds})
                    </td>
                    <td class="py-3 px-4">${bet.betAmount}</td>
                    <td class="py-3 px-4 text-sm">
                        ${new Date(bet.betTime).toLocaleString('zh-CN', {
                            month: '2-digit',
                            day: '2-digit',
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit'
                        })}
                        <br>
                        <span class="${timeDiff <= 0 ? 'text-red-500' : ''} text-xs">${timeDiffText}</span>
                    </td>
                    <td class="py-3 px-4">
                        ${statusBadge}
                        <br>
                        <span class="text-xs text-gray-500">${bet.strategy}</span>
                    </td>
                    <td class="py-3 px-4">
                        ${bet.status === "等待中" ? `
                            <button onclick="editPendingBetTime('${bet.id}')" 
                                class="text-gray-500 hover:text-gray-700 mr-2"
                                title="修改时间">
                                <i class="fa fa-edit"></i>
                            </button>
                            <button onclick="removeFromPending('${bet.id}')" 
                                class="text-red-500 hover:text-red-700"
                                title="移除">
                                <i class="fa fa-trash"></i>
                            </button>
                        ` : `
                            <button onclick="removeFromPending('${bet.id}')" 
                                class="text-gray-400 hover:text-gray-600"
                                title="清除记录">
                                <i class="fa fa-trash"></i>
                            </button>
                        `}
                    </td>
                `;
                
                tableBody.appendChild(tr);
            });
        }

        // 从待投注列表移除
        function removeFromPending(betId) {
            const initialLength = AppState.pendingBets.length;
            AppState.pendingBets = AppState.pendingBets.filter(bet => bet.id !== betId);
            
            if (AppState.pendingBets.length < initialLength) {
                Logger.info(`已从待投注列表移除项目 #${betId}`);
                renderPendingBetsTable();
            }
        }

        // 更新服务状态显示
        function updateServiceStatus() {
            const statusElement = document.getElementById("serviceStatus");
            const startBtn = document.getElementById("startServiceBtn");
            const stopBtn = document.getElementById("stopServiceBtn");
            
            if (AppState.getServiceRunning()) {
                statusElement.textContent = "运行中";
                statusElement.className = "text-success font-medium";
                startBtn.disabled = true;
                stopBtn.disabled = false;
            } else {
                statusElement.textContent = "已停止";
                statusElement.className = "text-gray-500 font-medium";
                startBtn.disabled = false;
                stopBtn.disabled = true;
            }
        }

        // 页面加载完成初始化
        document.addEventListener("DOMContentLoaded", () => {
            // 初始化界面元素
            document.getElementById("apiKeyInput").value = ApiKeyManager.get();
            
            const hms = convertToHMS(CONFIG.state.refreshInterval);
            document.getElementById("refreshHoursInput").value = hms.hours;
            document.getElementById("refreshMinutesInput").value = hms.minutes;
            document.getElementById("refreshSecondsInput").value = hms.seconds;
            
            document.getElementById("targetUserIdInput").value = CONFIG.state.targetUserId;
            document.getElementById("advanceSecondsInput").value = CONFIG.state.advanceSeconds;
            document.getElementById("amountRangeInput").value = CONFIG.state.amountRange;
            document.getElementById("baseAmountInput").value = CONFIG.state.baseAmount;
            document.getElementById("betStrategySelect").value = CONFIG.state.betStrategy;
            document.getElementById("checkIntervalInput").value = CONFIG.state.checkInterval;
            document.getElementById("detailedLogModeCheckbox").checked = CONFIG.state.detailedLogMode;
            document.getElementById("pendingFilterSelect").value = CONFIG.state.pendingFilter;
            document.getElementById("followCheckIntervalInput").value = CONFIG.state.followCheckInterval;
            document.getElementById("aiPredictionEnabledCheckbox").checked = CONFIG.state.aiPredictionEnabled;
            document.getElementById("scheduleEnabledCheckbox").checked = CONFIG.state.scheduleEnabled;
            document.getElementById("scheduleStartTimeInput").value = CONFIG.state.scheduleStartTime;
            document.getElementById("scheduleStopTimeInput").value = CONFIG.state.scheduleStopTime;
            
            document.getElementById("autoRefreshBtn").textContent = CONFIG.state.autoRefresh ? "关闭自动刷新" : "开启自动刷新";
            
            const hmsms = convertMsToHMSMs(CONFIG.state.refreshInterval * 1000);
            document.getElementById("refreshIntervalDisplay").textContent = 
                `${hmsms.hours.toString().padStart(2, '0')}:${hmsms.minutes.toString().padStart(2, '0')}:${hmsms.seconds.toString().padStart(2, '0')}.${hmsms.milliseconds.toString().padStart(3, '0')}`;
            
            // 初始化表格
            renderBetTable();
            renderPendingBetsTable();
            updateServiceStatus();
            Logger.toggleDetailedMode(CONFIG.state.detailedLogMode);
            
            // 初始化定时任务
            if (CONFIG.state.scheduleEnabled) {
                setupSchedule();
            }
            
            Logger.info("系统已初始化完成，准备就绪");
        });
    </script>
</head>
<body class="bg-gray-50 font-sans">
    <div class="container mx-auto px-4 py-6 max-w-7xl">
        <header class="mb-8">
            <h1 class="text-[clamp(1.5rem,3vw,2.5rem)] font-bold text-dark mb-2">M-Team 馒头菠菜助手</h1>
            <p class="text-gray-500">智能投注辅助系统 - 专业版</p>
        </header>

        <!-- 服务状态与控制区 -->
        <div class="bg-white rounded-lg p-4 shadow-sm mb-6">
            <div class="flex flex-wrap items-center justify-between gap-4">
                <div>
                    <span class="text-gray-600">服务状态: </span>
                    <span id="serviceStatus" class="text-gray-500 font-medium">已停止</span>
                    <span class="ml-4 text-gray-600">下次刷新: </span>
                    <span id="refreshIntervalDisplay" class="font-mono text-primary"></span>
                </div>
                <div class="flex gap-2">
                    <button id="startServiceBtn" onclick="startService()" 
                        class="bg-success hover:bg-success/90 text-white px-4 py-2 rounded-md transition-colors">
                        <i class="fa fa-play mr-1"></i> 启动服务
                    </button>
                    <button id="stopServiceBtn" onclick="stopService()" disabled
                        class="bg-danger hover:bg-danger/90 text-white px-4 py-2 rounded-md transition-colors">
                        <i class="fa fa-stop mr-1"></i> 停止服务
                    </button>
                    <button id="autoRefreshBtn" onclick="toggleAutoRefresh()"
                        class="bg-primary hover:bg-primary/90 text-white px-4 py-2 rounded-md transition-colors">
                        关闭自动刷新
                    </button>
                    <button onclick="manualRefresh()"
                        class="bg-gray-200 hover:bg-gray-300 text-gray-800 px-4 py-2 rounded-md transition-colors">
                        <i class="fa fa-refresh mr-1"></i> 手动刷新
                    </button>
                    <button onclick="toggleLogModal()"
                        class="bg-gray-200 hover:bg-gray-300 text-gray-800 px-4 py-2 rounded-md transition-colors">
                        <i class="fa fa-log mr-1"></i> 日志
                    </button>
                </div>
            </div>
        </div>

        <!-- API设置区 -->
        <div class="bg-white rounded-lg p-4 shadow-sm mb-6">
            <h2 class="text-lg font-semibold mb-4 text-dark">API 配置</h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">API Key</label>
                    <input type="text" id="apiKeyInput" 
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary"
                        placeholder="输入API Key">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">目标用户ID（跟随策略用）</label>
                    <input type="text" id="targetUserIdInput" 
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary">
                </div>
                <div class="flex items-end">
                    <button onclick="verifyApiKey()"
                        class="w-full bg-primary hover:bg-primary/90 text-white px-4 py-2 rounded-md transition-colors">
                        <i class="fa fa-key mr-1"></i> 验证API
                    </button>
                </div>
            </div>
        </div>

        <!-- 策略配置区 -->
        <div class="bg-white rounded-lg p-4 shadow-sm mb-6">
            <h2 class="text-lg font-semibold mb-4 text-dark">投注策略配置</h2>
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">投注策略</label>
                    <select id="betStrategySelect" 
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary">
                        <option value="higher_odds">高赔率优先</option>
                        <option value="larger">押大</option>
                        <option value="smaller">押小</option>
                        <option value="follow">跟随目标用户</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">提前下注时间（秒）</label>
                    <input type="number" id="advanceSecondsInput" min="0" max="60" 
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">基础投注金额</label>
                    <input type="number" id="baseAmountInput" min="100" step="100" 
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">金额波动范围</label>
                    <input type="number" id="amountRangeInput" min="0" step="100" 
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary">
                </div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mt-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">检查间隔（秒）</label>
                    <input type="number" id="checkIntervalInput" min="0.1" step="0.1" 
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">跟随检查间隔（毫秒）</label>
                    <input type="number" id="followCheckIntervalInput" min="100" step="100" 
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">待投注筛选</label>
                    <select id="pendingFilterSelect" 
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary">
                        <option value="all">全部</option>
                        <option value="highest_odds">最高赔率</option>
                        <option value="highest_amount">最高金额</option>
                        <option value="ratio_based">最佳比例</option>
                    </select>
                </div>
                <div class="flex items-center space-x-2">
                    <input type="checkbox" id="aiPredictionEnabledCheckbox" checked
                        class="h-4 w-4 text-primary focus:ring-primary border-gray-300 rounded">
                    <label for="aiPredictionEnabledCheckbox" class="text-sm font-medium text-gray-700">启用AI预测</label>
                </div>
            </div>
        </div>

        <!-- 刷新配置区 -->
        <div class="bg-white rounded-lg p-4 shadow-sm mb-6">
            <h2 class="text-lg font-semibold mb-4 text-dark">刷新配置</h2>
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">刷新间隔 - 小时</label>
                    <input type="number" id="refreshHoursInput" min="0" max="24" 
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">刷新间隔 - 分钟</label>
                    <input type="number" id="refreshMinutesInput" min="0" max="59" 
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">刷新间隔 - 秒</label>
                    <input type="number" id="refreshSecondsInput" min="5" max="59" 
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary">
                </div>
                <div class="flex items-end">
                    <button onclick="setRefreshInterval()"
                        class="w-full bg-primary hover:bg-primary/90 text-white px-4 py-2 rounded-md transition-colors">
                        <i class="fa fa-clock-o mr-1"></i> 设置刷新间隔
                    </button>
                </div>
            </div>
        </div>

        <!-- 定时任务配置区 -->
        <div class="bg-white rounded-lg p-4 shadow-sm mb-6">
            <h2 class="text-lg font-semibold mb-4 text-dark">定时任务</h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-center">
                <div class="flex items-center space-x-2">
                    <input type="checkbox" id="scheduleEnabledCheckbox"
                        class="h-4 w-4 text-primary focus:ring-primary border-gray-300 rounded">
                    <label for="scheduleEnabledCheckbox" class="text-sm font-medium text-gray-700">启用定时任务</label>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">启动时间</label>
                    <input type="time" id="scheduleStartTimeInput" 
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">停止时间</label>
                    <input type="time" id="scheduleStopTimeInput" 
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary">
                </div>
            </div>
            <div class="mt-4">
                <button onclick="saveParameters()"
                    class="bg-primary hover:bg-primary/90 text-white px-4 py-2 rounded-md transition-colors">
                    <i class="fa fa-save mr-1"></i> 保存所有配置
                </button>
            </div>
        </div>

        <!-- 可投注项目表格 -->
        <div class="bg-white rounded-lg shadow-sm mb-6 overflow-hidden">
            <div class="p-4 border-b">
                <h2 class="text-lg font-semibold text-dark">可投注项目</h2>
            </div>
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">序号</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">项目名称</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">描述</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">可选项（赔率）</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">结束时间</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">AI预测</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">跟随操作</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">待投操作</th>
                        </tr>
                    </thead>
                    <tbody id="betTableBody" class="bg-white divide-y divide-gray-200">
                        <!-- 表格内容由JS动态生成 -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- 待投注项目表格 -->
        <div class="bg-white rounded-lg shadow-sm mb-6 overflow-hidden">
            <div class="p-4 border-b">
                <h2 class="text-lg font-semibold text-dark">待投注项目</h2>
            </div>
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">序号</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">项目名称</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">选择项（赔率）</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">投注金额</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">预计投注时间</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">状态</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">操作</th>
                        </tr>
                    </thead>
                    <tbody id="pendingBetsTableBody" class="bg-white divide-y divide-gray-200">
                        <!-- 表格内容由JS动态生成 -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- 底部状态栏 -->
        <div class="bg-white rounded-lg p-4 shadow-sm text-center text-gray-500 text-sm">
            <p>M-Team 馒头菠菜助手 © 2023 | 专业版 v1.0.0</p>
        </div>
    </div>

    <!-- 日志弹窗 -->
    <div id="logModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-4xl max-h-[80vh] flex flex-col">
            <div class="p-4 border-b flex justify-between items-center">
                <h3 class="text-lg font-semibold text-dark">系统日志</h3>
                <div class="flex gap-2">
                    <button onclick="Logger.clear()" 
                        class="text-gray-500 hover:text-gray-700 px-3 py-1 rounded-md border border-gray-300 hover:bg-gray-50">
                        <i class="fa fa-trash mr-1"></i> 清空
                    </button>
                    <button onclick="toggleLogModal()" 
                        class="text-gray-500 hover:text-gray-700 px-3 py-1 rounded-md border border-gray-300 hover:bg-gray-50">
                        <i class="fa fa-times mr-1"></i> 关闭
                    </button>
                </div>
            </div>
            <div id="logModalPanel" class="flex-1 overflow-y-auto p-4 text-sm"></div>
            <div class="p-4 border-t flex items-center">
                <div class="flex items-center space-x-2">
                    <input type="checkbox" id="modalDetailedLogModeCheckbox" 
                        checked="${CONFIG.state.detailedLogMode}"
                        class="h-4 w-4 text-primary focus:ring-primary border-gray-300 rounded">
                    <label for="modalDetailedLogModeCheckbox" class="text-sm font-medium text-gray-700">显示详细日志</label>
                </div>
                <script>
                    document.getElementById('modalDetailedLogModeCheckbox').checked = CONFIG.state.detailedLogMode;
                    document.getElementById('modalDetailedLogModeCheckbox').addEventListener('change', function() {
                        CONFIG.state.detailedLogMode = this.checked;
                        document.getElementById('detailedLogModeCheckbox').checked = this.checked;
                        Logger.toggleDetailedMode(this.checked);
                    });
                </script>
            </div>
        </div>
    </div>

    <!-- 小日志面板 -->
    <div class="fixed bottom-4 right-4 bg-white rounded-lg shadow-lg w-80 max-h-64 overflow-hidden z-40">
        <div class="p-2 bg-gray-100 flex justify-between items-center">
            <span class="text-xs font-medium text-gray-700">系统日志</span>
            <button onclick="toggleLogModal()" class="text-xs text-primary">查看全部</button>
        </div>
        <div id="logPanel" class="p-2 overflow-y-auto max-h-[calc(64vh-2rem)]"></div>
    </div>
</body>
</html>
						
